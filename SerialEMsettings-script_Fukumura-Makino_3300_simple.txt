MaxMacros	60
Macro	1
ScriptName TakeAtlas

#===================================================================
# Script for taking Atlas (Full Montage, Global Map, Grid Map etc...)
#     This script crashes for some reason with SerialEM4.0...
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# Just click "Run".
# All windows are refreshed. The microscope and the camera is automatically set for the Atlas condition.
# When it starts to run, a window will pop up. Just set the session folder for your grid. 
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

# ============================
# Parameters
# ============================
exp_time = 1 # [sec]
spot_atlas = 7 # Spot Size for Atlas. -1 for default.
CLapt_before = 1 # CLapt for Atlas. 0: Remove, 1: No.1, 2: No.2, 3:No.3, 4:No.4
CLapt_after = 0 # CLapt after taking atlas for Square. 0: Remove, 1: No.1, 2: No.2, 3:No.3, 4:No.4

piece_X = -1 #-1
piece_Y = -1 #-1

# ===========================
# Advanced setting parameters
# ===========================
# Set initial BeamShift before taking atlas?
setBSforAtlas = 0 # 0:No, 1:Yes

# Set initial BeamShift after taking atlas?
setBSforSquare = 0 # 0:No, 1:Yes

# Apply fixed shift to marker value from Atlas to Squaer after taking Atlas?
shift_atlas2square = 1 # 0:No, 1:Yes

# GoTo Square mag after taking montage?
goto_Square = 1 # 0:No, 1:Yes, 2: Show dialog box


# ============================
# main
# ============================

batchProcess = 0
CallFunction TakeAtlas::Core $exp_time $spot_atlas $CLapt_before $CLapt_after $setBSforAtlas $setBSforSquare $shift_atlas2square $goto_Square $batchProcess 

#set beam blanking after take atlas
SetBeamBlank 1

##############################################################

Function Core 9 0 exp_time spot_atlas CLapt_before CLapt_after setBSforAtlas setBSforSquare shift_atlas2square goto_Square batchProcess

    SuppressReports 
    ClearPersistentVars 
    CallFunction EMProperties::LoadAdditionalProperties

    # Set piece number of Atlas
    If $piece_X < 0
       piece_X = $fullFrameX
    EndIf
    If $piece_Y < 0
       piece_Y = $fullFrameY
    EndIf

    If $camForAtlas == 4
        Echo ===> This script does not support this camera.
        Echo ===> Will set only illumination and magnification. Please make full montage manually later on.
    EndIf

    
    # ==== Open Beam valve =======
    SetBeamBlank 1
    ReportColumnOrGunValve 
    If $repVal1 == 0
        SetColumnOrGunValve 1
    EndIf

    # ========= Open/Reset Navigator File =========

    ReportIfNavOpen
    If $repVal1 == 2
        SaveNavigator 
        CloseNavigator 
    Endif 
    OpenNavigator


    # ========= Setup file path for Atlas map =========
    # Setup Session directory
    If $batchProcess == 0
        Echo ===> Please set your session directory.
        UserSetDirectory
        ReportDirectory
        session_dir = $repVal1
    EndIf
    SetDirectory $session_dir

    # Setup atlas map file
    atlas_map @= Atlas.mrc
    path_to_atlas = $session_dir\$atlas_map

    CloseFile
    RemoveFile $path_to_atlas


    # ========= Set  mode for detector =========
    If $camForAtlas == 0
        SetK2ReadMode V 1
        SetK2ReadMode F 1
        SetK2ReadMode T 1
        SetK2ReadMode R 1
        SetK2ReadMode M 1

        montBin = 1
    ElseIf $camForAtlas == 1
        SetK2ReadMode V 1
        SetK2ReadMode F 1
        SetK2ReadMode T 1
        SetK2ReadMode R 1
        SetK2ReadMode M 1

        montBin = 2
    ElseIf $camForAtlas == 2    # Old DE server
        SetK2ReadMode V 0
        SetK2ReadMode F 0
        SetK2ReadMode T 0
        SetK2ReadMode R 0
        SetK2ReadMode M 0

        montBin = 1
    ElseIf $camForAtlas == 3
        SetK2ReadMode V 0
        SetK2ReadMode F 0
        SetK2ReadMode T 0
        SetK2ReadMode R 0
        SetK2ReadMode M 0

        montBin = 2
    ElseIf $camForAtlas == 4
        SetProcessing V 2
        SetProcessing F 2
        SetProcessing T 2
        SetProcessing R 2
        SetProcessing M 0
        montBin = 1
    EndIf
    SetDoseFracParams R 0 0 0 0 0
    KeepCameraSetChanges 

    # ========= Take Atlas map =========
    # Setup illumination for Atlas
    SetLowDoseMode 0
    Delay 1 sec

    CallFunction Funcs::SetAtlasIllumination $CLapt_before
    MoveStageTo 0 0

    # -------- Escape ---------
    If $camForAtlas == 4
        Echo ===> Finish.
        Echo ===> Please make full montage from "Navigator > Monaging&Grids > Setup Full Mongate".
        #OKBox Finish setting. Please make full montage from "Navigator > Monaging&Grids > Setup Full Mongate".
        #SaveNavigator $session_dir\navigator.nav
        Exit
    EndIf
    # ------------------------------

    # ---------- To avoid wired error -----------
    SetBinning M $montBin
    SetExposure M $exp_time
    SetBinning R $montBin
    SetExposure R $exp_time
    KeepCameraSetChanges 

    # --- To avoid bug start ---
    RemoveFile $path_to_atlas
    OpenNewMontage 1 1  $path_to_atlas
    SetMontageParams 1 $overlap_x  $overlap_y $frame_x $frame_y 0 $montBin
    M
    CloseFile 
    # --- To avoid bug end ---

    CloseFile
    RemoveFile $path_to_atlas
    OpenNewMontage $piece_X $piece_Y $path_to_atlas
    SetBinning M $montBin
    SetExposure M $exp_time
    SetBinning R $montBin
    SetExposure R $exp_time
    KeepCameraSetChanges 
    # ----------------------------------------------------

    SetMontageParams 1 $overlap_x  $overlap_y $frame_x $frame_y 0 $montBin
    M
    NewMap
    SaveNavigator $session_dir\navigator.nav

    SnapshotToFile 0 1 3 JPG NONE $session_dir\atlas_snap.jpg


    # ===== Reset =====
    #ReInsertAperture 0
    CloseFile

    # ========= Atlas to Square =========
    # Flag for shift.
    If $shift_atlas2square == 2
        YesNoBox Go to Square mag?
        #0:No, 1:yes
        If $repVal1 == 1 
            shift_atlas2square = 1
        EndIf
    EndIf

    # Flag for Goto Square.
    If $goto_Square == 2
       YesNoBox Go to Square mag?
       #0:No, 1:yes
       If $repVal1 == 1 
          goto_Square = 1
       Endif 
    Endif 

    If $shift_atlas2square == 1
        Echo Apply shift [$atlas2square_x, $atlas2square_y]
        
        div = 3 # For larger than 100 um shift
        smallShiftX = $atlas2square_x / $div 
        smallShiftY = $atlas2square_y / $div 
        Loop $div iter
            ShiftItemsByMicrons $smallShiftX $smallShiftY
        EndLoop
    Else
        Echo ===> Do not apply shift.
    EndIf

    If $goto_Square == 1
       SetMag $default_SquareMag
       CallFunction Funcs::SetSquareIllumination $CLapt_after
    Endif 

EndFunction
EndMacro
Macro	2
ScriptName TakeSquares

#===================================================================
# Script for taking multiple square images. 
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Take square position by "Add points" in Navigator window.
# 2. Check "Collapse" to group the points and Check Acquire to all the points selected.
# 3. Start this script from "Navigator > Acquire at items".
#     After running this script, "Squares" folder is created in the session folder and the sqare images are saved.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

# =================
# Parameters
# =================
exp_time = 1 #[sec]
SquareMag = 150

binFactor = 1

CLapt_before = 1 # CLapt for taking square. 0: Remove, 1: No.1, 2: No.2, 3:No.3, 4:No.4
CLapt_after = 0 # CLapt after taking squares. 0: Remove, 1: No.1, 2: No.2, 3:No.3, 4:No.4

# ===========================
# Advanced setting parameters
# ===========================
# Set initial BeamShift after taking squares?
setBSforLD = 1

# Adjust eucentric height at the first square
adjust_eucentric = 0 # 0:No, 1:Yes, 2: Show dialog box

# Apply fixed shift to marker value from Atlas to Square before taking squares?
shift_atlas2square = 0 # 0:No, 1:Yes, 2: Show dialog box

# Go to LowDose mode after taking squares?
goto_LowDose = 1 # 0:No, 1:Yes, 2: Show dialog box

# Apply fixed shift to marker value from Square to LowDoseMode after taking squares?
shift_square2view = 1 # 0:No, 1:Yes, 2: Show dialog box

# Below parameter is used for adding square when you are at LowDoseMode
shift_view2square = 0 # 0:No, 1:Yes

# Run find vector and set Focus/Trial position
set_focus_trial_pos = 1 # 0:No, 1:Yes

# Skip navigation
show_navigation = 1 # 0:No, 1:Yes

# ============================
# Main
# ============================

CallFunction TakeSquares::Core

#set beam blanking after take square
SetBeamBlank 1

#########################################################

Function Core

    CallFunction EMProperties::LoadAdditionalProperties

    # Initialize
    apply_atlas2square = 0
    apply_square2view = 0
    apply_eucentric = 0

    SetBeamBlank 1

    IsVariableDefined FIRSTNAVDONE
    If $repVal1 == 0
        # set FIRSTNAVDONE
        FIRSTNAVDONE := 0
    EndIf 

    #==== Open Beam valve =======
    ReportColumnOrGunValve 
    If $repVal1 == 0
        SetColumnOrGunValve 1
    EndIf 
    #=========================

    # ========= Set  mode for detector =========
    If $camForSquare == 0
        SetK2ReadMode V 1
        SetK2ReadMode F 1
        SetK2ReadMode T 1
        SetK2ReadMode R 1
        SquareBin = 2
    ElseIf $camForSquare == 1
        SetK2ReadMode V 1
        SetK2ReadMode F 1
        SetK2ReadMode T 1
        SetK2ReadMode R 1
        SquareBin = 2
    ElseIf $camForSquare == 2    # Old DE server
        SetK2ReadMode V 0
        SetK2ReadMode F 0
        SetK2ReadMode T 0
        SetK2ReadMode R 0
        SquareBin = 1
    ElseIf $camForSquare == 3
        SetK2ReadMode V 0
        SetK2ReadMode F 0
        SetK2ReadMode T 0
        SetK2ReadMode R 0
        SquareBin = 2
    ElseIf $camForSquare == 4
        SetProcessing V 2
        SetProcessing F 2
        SetProcessing T 2
        SetProcessing R 2
        SetProcessing M 0
        SquareBin = 1
    EndIf
    SquareBin = $SquareBin $binFactor
    SetBinning R $SquareBin
    KeepCameraSetChanges
    #=========================

    ReportMag mag
    ReportLowDose
    isLowDoseOn = $repVal1

    SetLowDoseMode 0
    CallFunction Funcs::CustomSetSlitIn 0
    SetMag $SquareMag

    Echo ===> DEBUG firstnavdone $FIRSTNAVDONE

    If $FIRSTNAVDONE == 0
       Delay 5 sec
       CallFunction Funcs::SetSquareIllumination $CLapt_before

        ReportNumNavAcquire 
        numOfNaviAcq = $repVal1
        echo $numOfNaviAcq squares are selected and about to exposure...

        #====  Align FOV from Atlas to Square=======
        If $shift_atlas2square == 2
            YesNoBox Do Align FOV Atlas to Square? (Nomally -> Yes. / If you already have square maps -> No)
            #0:no, 1:yes
            If $repVal1 == 1 
                shift_atlas2square = 1
            EndIf
        EndIf

        If $shift_atlas2square == 1
            Echo ===> Apply shift (Atlas to Square).
            Echo Apply shift [$atlas2square_x, $atlas2square_y]

            div = 3 # For larger than 100 um shift
            smallShiftX = $atlas2square_x  / $div 
            smallShiftY = $atlas2square_y / $div 
            Loop $div iter
               ShiftItemsByMicrons $smallShiftX $smallShiftY
            EndLoop
        Else
            Echo ===> Do not apply shift (Atlas to Square).
        EndIf
        #=========================

        #====  Align FOV from View to Square =======
        If $shift_view2square == 1
            If ($mag >= 1500) OR ($isLowDoseOn == 1)
                Echo ===> Apply shift (View to Square).
                view2squar_x = -1 * $square2view_x
                view2squar_y = -1 * $square2view_y
                Echo Apply shift [$view2squar_x, $view2squar_y]

                div = 3 # For larger than 100 um shift
                smallShiftX = $view2squar_x  / $div 
                smallShiftY = $view2squar_y / $div 
                Loop $div iter
                   ShiftItemsByMicrons $smallShiftX $smallShiftY
                   ShiftItemsByMicrons $smallShiftX $smallShiftY
                EndLoop 

                
            Else
                Echo ===> Do not apply shift (View to Square). LowMag is already ON.
            EndIf
        Else
            Echo ===> Do not apply shift (View to Square).
        EndIf
        #=========================

        If $koehler_z_offset != 0
            MoveStageTo 0 0 $koehler_z_offset
        EndIf

        #==== Adjust eucentric height ====
        If $adjust_eucentric == 2
            YesNoBox Adjust global eucentric hight ?
            If $repVal1 == 1
                adjust_eucentric = 1
            EndIf
        EndIf

        If ($adjust_eucentric == 1) AND ($koehler_z_offset == 0)
            Echo ===> Adjust eucentircity for whole squares
            ReportTiltAngle TT
            Eucentricity 1
            TiltTo $TT
        Else
            Echo ===> Skip adjust eucentircity for whole squares
        EndIf
        #=========================

        UpdateGroupZ 

        FIRSTNAVDONE := 1
        MoveToNavItem 
    EndIf 

    SaveNavigator
    CloseFile

    ReportMag mag

    # Current Item info
    ReportNavItem
    item_label = $navLabel

    # Set file path for square maps
    ReportNavFile 1
    NAVIGATOR_PATH = $repVal3

    squares @= squares.mrc
    path_to_squares = $NAVIGATOR_PATH$squares
    Echo ===> DEBUG path_to_squares $path_to_squares 

    # Set SquareJPG folder
    sqJPG_dir @= SquaresJPG
    path_to_sqJPG = $NAVIGATOR_PATH$sqJPG_dir
    RunInShell mkdir $path_to_sqJPG

    totalSq @= TotalSquares.txt
    path_to_totalSq = $path_to_sqJPG\$totalSq

    # Set square number
    Try 
        ReadTextFile sq_count $path_to_totalSq
     Catch
        sq_count = 0
     EndTry

    # Open square file
    Try
        OpenOldFile $path_to_squares
    Catch
        OpenNewFile $path_to_squares
    EndTry

    # Set JPG square image and info name 
    sqJPG_file = sq_$sq_count.jpg
    ##sqJPG_file = $sq_count_SquareMap$item_label.jpg
    path_to_sqJPG_file = $path_to_sqJPG\$sqJPG_file
    sqJPG_info = sqJPG_info_$sq_count.txt
    path_to_sqJPG_info = $path_to_sqJPG\$sqJPG_info

    # Set camera parameters
    SetExposure R $exp_time
    SetDoseFracParams R 0 0 0 0 0

    # Take square image and save it
    R
    Save
    NewMap
    SaveToOtherFile A JPG NONE $path_to_sqJPG_file

    # Reset Camera parameters
    RestoreCameraSet R

    # Save image info 
    ImageProperties A
    dimX = $repVal1
    dimY = $repVal2
    bin = $repVal3
    exposure = $repVal4
    pixsize = $repVal5 #[nm]
    ReportMagIndex mag_idx

    RunInShell echo SquareMap : $item_label >> $path_to_sqJPG_info
    RunInShell echo MagIndex : $mag_idx >> $path_to_sqJPG_info
    RunInShell echo Mag : $mag >> $path_to_sqJPG_info
    RunInShell echo X : $dimX >> $path_to_sqJPG_info
    RunInShell echo Y : $dimY >> $path_to_sqJPG_info
    RunInShell echo bin : $bin >> $path_to_sqJPG_info
    RunInShell echo exposure : $exposure >> $path_to_sqJPG_info
    RunInShell echo pixsize : $pixsize >> $path_to_sqJPG_info

    sq_count = $sq_count + 1
    RunInShell echo $sq_count > $path_to_totalSq

    CloseFile

    #====  Call AlignFOV_AtlasToSquare ====
    ReportNumNavAcquire
    If $repVal1 == 1
        # Flag for applying shift,
        If $shift_square2view == 2
            YesNoBox Apply ShiftToMarker?
            If $repVal1 == 1 
                shift_square2view = 1
            EndIf
        EndIf

        # Flag for going to LowDoseMode.
        If $goto_LowDose == 2
            YesNoBox Go to LowDose mode?
            If $repVal1 == 1 
                goto_LowDose = 1
            EndIf
        EndIf

        If $shift_square2view == 1
            If $camForSquare == 1
                SetK2ReadMode V 0
                SetK2ReadMode F 0
                SetK2ReadMode T 0
                SetK2ReadMode R 1

                SetBinning V 2
                SetBinning F 2
                SetBinning T 2
                SetBinning R 2
            EndIf
            KeepCameraSetChanges 

            Echo ===> Apply shift (Square to View).
            ShiftItemsByMicrons $square2view_x $square2view_y
        Else
            Echo ===> Do not apply shift (Square to View).
        EndIf

        If $goto_LowDose == 1
            SetLowDoseMode 1
            GoToLowDoseArea R
            Delay 10 sec
            SetEucentricFocus
            ResetDefocus
            Delay 5 sec
            GoToLowDoseArea V

            If $set_focus_trial_pos == 1
                Call SetFocusTrialPosition
            EndIf

            RunInShell $setCLapt $CLapt_type $CLapt_after

            If $setBSforLD == 1
               GoToLowDoseArea V
               Try
                  ReadTextFile lastBS $WORKING_DIR_PATH\lastBeamShift_at_View.txt
                  SetBeamShift $lastBS[1] $lastBS[2]
               Catch
                  Echo ===> Cannot read $WORKING_DIR_PATH\lastBeamShift_at_View.txt
               EndTry
            Endif 
        Else
            # commented out by gaony
            # Call FindInitVectors
            Echo ===> Skip FindVectors
        EndIf

        FIRSTNAVDONE := 0

        If $show_navigation == 1
            OKBox Finished. Please setup LowDoseMode.
        EndIf
        
        ScreenDown
    EndIf 

EndFunction
EndMacro
Macro	4
ScriptName Z_byV

#===================================================================
# Adjust Z height by View mode.
#     LowDoseMode must be set up before running this script.
#     Navigator file must be opened.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# Just click "Run".
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion Repository.
# Modified by TF and FM.
#===================================================================

errZ = 5 #[um]

intensity_threshold = 100 #added by GaoNY
Z_byV_failed = 0 #added by GaoNY

SuppressReports 
CallFunction EMProperties::LoadAdditionalProperties

Echo ===== Running Z_byV =====
#====================================
# for defocus offset of V in Low Dose, save it
# ===================================
GoToLowDoseArea V

#==================
# Set object lens 
#==================
ReportBeamShift 
bsx_beforeZbyV = $repVal1
bsy_beforeZbyV = $repVal2

#SaveFocus # this is used for "High defocus mag"
#SetEucentricFocus

#ReportDefocus currentDefocus #commented out by GaoNY

#====================================================
# Save BeamShift value
#====================================================
RunInShell echo $bsx_beforeZbyV $bsy_beforeZbyV > $WORKING_DIR_PATH\lastBeamShift_at_View.txt

#===========
# Adjust Z
#===========
ReportStageXYZ originalX originalY originalZ

Loop 10

   IsVariableDefined targetZ
   If $repVal1 == 0
      targetZ = 0
   Endif 

   #G -1 1 # autofocus with view #commented out by GaoNY
   #ReportAutofocus MeasuredDEF #commented out by GaoNY
   #totalOffset = $offset_for_Z_byV + $targetZ + $currentDefocus #commented out by GaoNY
   
   #block added by GaoNY
   G -1 2
   ReportAutofocus MeasuredDEF
   ReportMeanCounts
   ViewCounts = $repVal1
   totalOffset = $offset_for_Z_byV + $targetZ
   #block finished 

   Echo ===> Target Z : $totalOffset um
   Echo ===> Measured defoucs : $MeasuredDEF um
   lowerRange = $totalOffset - $errZ
   upperRange = $totalOffset + $errZ

   neededZ = $MeasuredDEF - $totalOffset 
   Z = -1 * $neededZ
   relax_z1 = $Z / ABS ($Z) * $backlash_z
   relax_z2 = -1 * $relax_z1

   CallFunction Funcs::WillZExeedRange $neededZ
   
   #block added by GaoNY
   If ($repVal1 == 1) OR ($ViewCounts < $intensity_threshold)
      Echo ===> Fail to adjust Eucentric height.
      Echo ===> Back to original Stage height. 
      MoveStageTo $originalX $originalY $originalZ
      skip_message @= "Skipped. Hit the limitation of Z height."
      ReportIfNavOpen
      If $repVal1 == 1
         ReportGroupStatus
         If $repVal1 != -1
            CallFunction Funcs::AnnotateSkipItem $skip_message
            SkipAcquiringGroup
            #SkipAcquiringNavItem
            Z_byV_failed = 1
         EndIf
      EndIf       
      Exit
   EndIf	  
   #block finished
   
   #commented out by GaoNY
   #If ($repVal1 == 1) 
       #Echo !!!!!! Z will exceed the safety range. Try again. !!!!!!
       #Continue 
   #EndIf

   If ($lowerRange < $MeasuredDEF) AND ($MeasuredDEF < $upperRange)
      Echo ===> Finished Z_byV.
      Break 
   Endif 

   MoveStage 0 0 $relax_z1
   MoveStage 0 0 $Z
   MoveStage 0 0 $relax_z2

   Z = ROUND $Z 2
   Echo Z has moved --> $Z micron 
EndLoop

#=========================================
# Restore the defocus set in V originally
# ========================================
#RestoreFocus # this is used for "High defocus mag"
SetBeamShift $bsx_beforeZbyV $bsy_beforeZbyV
EndMacro
Macro	5
 ScriptName TakeHoleTemplate

#===================================================================
# Script to take hole template image.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Roughly Adjust Z heght by "Z_byV".
# 2. Adjust field of view to the hole by the mouse right button drag.
# 3. Take View image.
# 4. "Run" this scrpt.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    # ============================
    # Parameters
    # ============================

    exposure_time = 5
    show_navigation = 0 # 0:No, 1: Yes

    # ============================
    # Main
    # ============================
    SuppressReports

    Echo ============= Start TakeHoleTemplate =============
    
    # Set View mode
    SetLowDoseMode 1
    GoToLowDoseArea V
    V    

    If $show_navigation == 1
        YesNoBox Template should be high contrast hole (e.g. empty hole). Are you on good position?
        If $repVal1 == 0
            OKbox Please go to good position.
            Exit
        EndIf
        YesNoBox Z must be adjusted. Have you done Z_byV?
    EndIf

    If $repVal1 == 0
       Call Z_byV
       V
       OKbox Please go to the center of the hole by ImageShift or Stage movement, and re-run TakeHoleTemplate.
       Exit
    EndIf

    # Set file path
    ReportNavFile 1
    NAVIGATOR_PATH = $repVal3
    file_name @= hole_template.mrc
    file_path @= $NAVIGATOR_PATH$file_name

    # Set camera params
    SetExposure V $exposure_time

    # Take View image
    V
    Copy A T

    # Save file
    SaveToOtherFile A MRC NONE $file_path

    # Reset camera params
    RestoreCameraSet V

    # Result
    Echo ===> Finish TakeHoleTemplate.
    Echo ===> Hole template image was saved as $file_path

    # Set ImageShift 0 0
    SetImageShift 0 0
    Echo ===> ImageShift is set to 0 0
EndMacro
Macro	6
ScriptName AlignToHole

#===================================================================
# Align to the hole by template matching.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Run "TakeHoleTemplate" script if you need.
# 2. Then just "Run".
#    This uses the hole alignment parameters in "Parameters" script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

# ============================
# Parameters
# ============================

# Threshold for realigning to hole by stage
maxholeshift = 0.2 * 1000 #[um x 1000]

# Maximum iteration for hole alignment
max_align_iter = 10

# Use IS for the final alignment?
align_byIS = 1 # 0:No, 1:Yes

# Template buffer for hole alignment
template_buffer = T

# Use YoneoLocker
use_YL = 0 # 0:No, 1:Yes

# ============================
# Main
# ============================
# Initialize 
SuppressReports

CallFunction EMProperties::LoadAdditionalProperties

grid_type = 1

Echo ====== Start AlignToHole =======

# Set View mode of LD
SetLowDoseMode 1
GoToLowDoseArea V

# Read hole image
If $use_YL == 0
    CallFunction Funcs::ReadHoleImage
EndIf

# Start hole alignment
CallFunction Funcs::AlignToHole $maxholeshift $max_align_iter $align_byIS $use_YL $template_buffer
EndMacro
Macro	7
ScriptName TestShot

#===================================================================
# Script for taking record with saving image and measuring ice thickness and exposure optimization.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Move to the hole position.
# 2. Adjust focus by "AutoFocus" or "AutoFocusRoutine" script.
# 3. Just click "Run" instead of Record.
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion repository.
# Modified by TF and FM.
#===================================================================

# ============================
# Parameters
# ============================
measure_ice_thickness = 1 # 0: No, 1:Yes
show_optimized_doseFrac = 1 # 0: No, 1: Yes
target_total_dose = 80 # [e/A^2]
target_dose_per_frame = 1 # [e/frame]

# ============================
# Main
# ============================

SuppressReports
CallFunction EMProperties::LoadAdditionalProperties

GoToLowDoseArea R

If $hasOmegaFilter == 0
    measure_ice_thickness = 0
EndIf

If $recordCam == 0
    Echo ===> This script does not support your camera.
    Return
EndIf

Echo ======= Start TestShot =======

# Set save folder
ReportNavFile 1
NAVIGATOR_PATH = $repVal3
doseCheck_dir @= TestShot
path_to_doseCheck = $NAVIGATOR_PATH$doseCheck_dir
RunInShell mkdir $path_to_doseCheck

img_count_file @= img_count.txt
path_to_img_count @= $path_to_doseCheck\$img_count_file

Try 
    ReadTextFile img_count $path_to_img_count
Catch
    img_count = 0
EndTry

img_count = $img_count + 1

img_file @= $path_to_doseCheck\$img_count.jpg
img_file_mrc @= $path_to_doseCheck\$img_count.mrc
img_info_file @= $path_to_doseCheck\$img_count_info.txt
fft_img  @= $path_to_doseCheck\$img_count_FFT.jpg

# Recommended dose rate
If ($recordCam == 1)
    thresh_dose = 8.0
    # Set camera params
    SetBinning R 1
    Echo ===> Binning is set to 1

ElseIf ($recordCam == 2)
    ReportK3CDSmode
    If ($repVal1 == 1)
        thresh_dose = 16.0
    Else
        thresh_dose = 15.0
    EndIf
    # Set camera params
    SetBinning R 1
    Echo ===> Binning is set to 1

ElseIf ($recordCam == 3)
    thresh_dose = 3.5
    # Set camera params
    SetBinning R 2
    Echo ===> Binning is set to 2

ElseIf ($recordCam == 4)
    thresh_dose = 40
    # Set camera params
    SetBinning R 2
    Echo ===> Binning is set to 2

Else
    Echo ===> No detector type of $recordCam.
    Exit
EndIf

KeepCameraSetChanges R

ReportTargetDefocus TD

CallFunction Funcs::CustomReportEnergyFilter
initailslit_status = $repVal3

# Take record and measure ice thickness
ice_thickness = 1
GoToLowDoseArea R
If $measure_ice_thickness == 1
    # SlitIn
    SetDoseFracParams R 0 0 0 0 0
    CallFunction Funcs::CustomSetSlitIn 1
    Delay 2 sec
    UpdateLowDoseParams R
    R
    RestoreLowDoseParams R
    ElectronStats A
    electron_count = $repVal5
    Copy A B

    # Slit out
    ImageProperties A
    exposure = $repVal4
    If $exposure > 2
        SetExposure R 2
    EndIf
    SetDoseFracParams R 0 0 0 0 0
    CallFunction Funcs::CustomSetSlitIn 0
    UpdateLowDoseParams R
    R
    ElectronStats A
    electron_count_NoSlit = $repVal5
    RestoreCameraSet R
    RestoreLowDoseParams R

    ice_thickness = $electron_count / $electron_count_NoSlit
    If $ice_thickness > 1
        ice_thickness = 1
    EndIf

    Copy B A
Else
    R
    ElectronStats A
    electron_count = $repVal5
EndIf

# Show FFT
FFT A
Copy AF F

# Save image
SaveToOtherFile A JPG NONE $img_file
SaveToOtherFile A MRC NONE $img_file_mrc
SaveToOtherFile F JPG NONE $fft_img
RunInShell echo $img_count > $path_to_img_count

# Imaging info
ImageProperties A
bin = $repVal3
exposure = $repVal4
pixsize = $repVal5 * 10

dose_rate = ( $electron_count / ($pixsize * $pixsize) ) / $ice_thickness
total_dose = $dose_rate * $exposure
solved_exposure = $target_total_dose / $dose_rate
solved_frame_num = NEARINT ($target_total_dose / $target_dose_per_frame)
solved_frame_time = $solved_exposure / $solved_frame_num

Echo DEBUG $initailslit_status
GoToLowDoseArea R
SetLDContinuousUpdate 1
CallFunction Funcs::CustomSetSlitIn $initailslit_status
Delay 3
SetLDContinuousUpdate 0

ReportAlpha alpha
ReportSpotSize spot_size
ReportPercentC2 brightness
ReportMag mag
ReportStageXYZ stage_x stage_y stage_z

RunInShell echo $img_count > $img_count_file

# Report imaging info
Echo ----------------------------------------------------------------
RunInShell echo ---------------------------------------------------------------- >> $img_info_file

If $recordCam == 1
    Echo Detector type : K2
    RunInShell echo Detector type : K2 >> $img_info_file
ElseIf $recordCam == 2
    Echo Detector type : K3
    RunInShell echo Detector type : K3 >> $img_info_file
ElseIf $recordCam == 3
    Echo Detector type : DE64
    RunInShell echo Detector type : DE64 >> $img_info_file
ElseIf $recordCam == 4
    Echo Detector type : Apollo
    RunInShell echo Detector type : Apollo >> $img_info_file
Else
    Echo Detector type : Other
    RunInShell echo Detector type : Other >> $img_info_file
EndIf


Echo Image number : $img_count
Echo Spot : $spot_size
Echo Angle : $alpha
Echo Binning : $bin
Echo Pixel size (at x$mag) : $pixsize [A/px]
Echo Exposure time : $exposure [sec]
Echo Target Defocus : $TD [um]
Echo Acquisition point (X, Y, Z) : $stage_x $stage_y $stage_z [um]

RunInShell echo Image number : $img_count >> $img_info_file
RunInShell echo Spot : $spot_size >> $img_info_file
RunInShell echo Angle : $alpha >> $img_info_file
RunInShell echo Binning : $bin >> $img_info_file
RunInShell echo Pixel size (at x$mag) : $pixsize [A/px] >> $img_info_file
RunInShell echo Exposure time : $exposure [sec] >> $img_info_file
RunInShell echo Target Defocus : $TD [um] >> $img_info_file
RunInShell echo Acquisition point (X, Y, Z) : $stage_x $stage_y $stage_z [um] >> $img_info_file

# Report dose info
If ($recordCam == 1) OR ($recordCam == 2) OR ($recordCam == 3) OR ($recordCam == 4)
    Echo ----------------------------------------------------------------
    RunInShell echo ---------------------------------------------------------------- >> $img_info_file

    Echo Dose rate on detector : $electron_count [e/px/s]
    Echo Dose rate on specimen : $dose_rate [e/A^2/s]
    Echo Total dose on specimen : $total_dose [e/A^2]

    RunInShell echo Dose rate on detector : $electron_count [e/px/s] >> $img_info_file
    RunInShell echo Dose rate on specimen : $dose_rate [e/A^2/s] >> $img_info_file
    RunInShell echo Total dose on specimen : $total_dose [e/A^2] >> $img_info_file

    If $measure_ice_thickness == 1
        Echo Ice thickness : $ice_thickness (Ratio : SlitIn / SlitOut)
        RunInShell echo Ice thickness : $ice_thickness >> $img_info_file (Ratio : SlitIn / SlitOut)
    EndIf

    If $electron_count > $thresh_dose
        Echo !!! You should lower the dose rate to avoid coinsidence loss.
        Echo !!! Recommended dose rate on your detector is less than $thresh_dose [e/px/s]

        RunInShell echo !!! You should lower the dose rate to avoid coinsidence loss. >> $img_info_file
        RunInShell echo !!! Recommended dose rate on your detector is less than $thresh_dose [e/px/s] >> $img_info_file

        OKBox "!!! You should lower the dose rate to avoid coinsidence loss. Recommended dose rate on your detector is less than $thresh_dose [e/px/s]"
    EndIf

    If $show_optimized_doseFrac == 1
        Echo ----------------------------------------------------------------
        RunInShell echo ---------------------------------------------------------------- >> $img_info_file
        Loop 10
            If ( MODULO ($solved_frame_num 2) == 0 )
                actual_dose_per_frame = $target_total_dose / $solved_frame_num
                Echo Optimized exposure time (Target total dose : $target_total_dose [e/A^2]) : $solved_exposure [sec]
                Echo Optimized frame time (Target dose per frame : $target_dose_per_frame [e/A^2/frame]) : $solved_frame_time [sec]
                Echo Number of frames : $solved_frame_num
                Echo Dose per frame : $actual_dose_per_frame [e/A^2/frame]

                RunInShell echo Optimized exposure time (Target total dose : $target_total_dose [e/A^2]) : $solved_exposure [sec] >> $img_info_file
                RunInShell echo Optimized frame time (Target dose per frame : $target_dose_per_frame [e/A^2/frame]) : $solved_frame_time [sec] >> $img_info_file
                RunInShell echo Number of frames : $solved_frame_num >> $img_info_file
                RunInShell echo Dose per frame : $actual_dose_per_frame [e/A^2/frame] >> $img_info_file

                If ($recordCam == 1) AND ($solved_frame_time < 0.1)
                    Echo !!! You must set longer frame time for K2!
                    Echo !!! Check dose again with reduced beam intensity!

                    RunInShell echo !!! You must set longer frame time for K2! >> $img_info_file
                    RunInShell echo !!! Check dose again with reduced beam intensity! >> $img_info_file

                    OKBox "!!! You must set longer frame time for K2! Check dose again with reduced beam intensity!"
                ElseIf ($recordCam == 3)
                    Echo ===> You need to set the parameters manually. (DE camera)
                Else
                    YesNoBox Set optimized parameters? "Exposure time: $solved_exposure [s]" "Frame time: $solved_frame_time [s]"
                    If $repVal1 == 1
                        SetExposure R $solved_exposure
                        SetFrameTime R $solved_frame_time
                        KeepCameraSetChanges
                    EndIf
                EndIf

                Break
            Else
                solved_frame_time = $solved_frame_time * 0.99 
                solved_frame_num = NEARINT ($solved_exposure / $solved_frame_time)
            EndIf
        EndLoop

    EndIf
    
EndIf

Echo ===> Finish
EndMacro
Macro	8
ScriptName AutoFocusRoutine

#===================================================================
# Script for auto focusing iteratively.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Set Focus area from LowDoseControl window or "SetFocusTrialPosition" script.
# 2. Roughly adjust Z height by "Z_byV" script if you need.
# 3. Move the stage to the hole position.
# 4. "Run" this script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

# ============================
# Parameters
# ============================

focus_method = 0 # 0: Z and OL, 1: Z

# 999 for default value, -1 for default option.
focus_error = 999 #[um]
settle_time = 999 #[sec]
max_focusZ_iter = 999
max_focus_iter = 999
z_settle_time = 999
OLFocusLimit = 999 #[um]
focus_th_low = 999 #[um]

focusOnRec = -1 # 0: Focus, 1: Record, -1: Default

# ============================
# Main
# ============================

Echo ===== Start AutoFocusRoutine =====

SuppressReports

updata_Z_afterFocus = 0

CallFunction EMProperties::LoadAdditionalProperties

# GoTo Focus mode
SetLowDoseMode 1
GoToLowDoseArea F

# Fix target defocus just in case
CallFunction CustomAutoFocus::FixInvalidDefocusValue 

# Set standard focus
Echo ===> Set standard focus
SetEucentricFocus

# Start AutoFocusing
If $focus_method == 0
    CallFunction CustomAutoFocus::AutoFocus_byOL
ElseIf $focus_method == 1
    CallFunction CustomAutoFocus::AutoFocus_byZ
EndIf

# Wait for settling
Echo ===> Settling $settle_time [sec]
Delay $settle_time sec

Echo ===> Finish AutoFocusing
EndMacro
Macro	10
ScriptName FindVectorsRoutine

#===================================================================
# Script of the combination of "Z_byV", "AlignToHole", "FindInitVectors", "FindVectors" and "CheckMultiHole" script.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Move stage to the area where holes can clearly be seen (to get enough contrast).
#     Empty hole region without any ice particles is the best area, but it should work unless holes are too thick.
# 2. Just "Run" this script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================


# ============================
# Parameters
# ============================
skip_focusing = 0 # 0: No, 1:Yes
skip_holeAlign = 0 # 0: No, 1:Yes
skip_InitVec = 1 # 0: No, 1:Yes
skip_checkAccuracy = 1 # 0: No, 1:Yes

show_navigation = 0 # 0:No, 1:Yes

grid_type = 1 # 0: lacey, 1: quantifoil,UltrAufoil
targetZ = -30 # [um]
using_ZbyV = 0 #1:yes, 0:no, use Z_byV by yes, use Z_byFocus by no

#If change aperture to 50um, please change both CLapt_before and CLapt_after to 3, @300II --> 1:150, 2:100, 3:50, 4:20
CLapt_before = 4
CLapt_after = 4

show_navigation = 0 # 0: No, 1:Yes

# ============================
# Main
# ============================

CallFunction EMProperties::LoadAdditionalProperties

SetColumnOrGunValve 1

GoToLowDoseArea V
V
If $show_navigation  == 1
   YesNoBox You must go to high contrast area. Are you ready?
   If $repVal1 == 0
      OKBox Please go to good square where you can see high contrast holes.
      Exit 
   Endif 
EndIf

# Z_byV
If $skip_focusing == 0
   If $using_ZbyV == 1
      Echo ===> Z_byV
      Call Z_byV
   Else
      Echo ===> Run AutoFocusRoutine
      Call AutoFocusRoutine
   Endif 
EndIf

# Hole alignment
If $skip_holeAlign == 0
   If $grid_type != 0
      Echo ===> Aligning to hole
      Call AlignToHole
   ElseIf $grid_type == 0
      Echo ===> Grid is lacey. Skip hole alignment.
   Endif 
Endif 

ReportNavFile 1
NAVIGATOR_PATH = $repVal3

# Find initial vector param
initVecFile @= Vector_init_param.txt
DoesFileExist $NAVIGATOR_PATH$initVecFile
If ($skip_InitVec == 0) OR ($repVal1 == 0)
      Echo ===> Finding the initial vector
      Call FindInitVectors
EndIf

# Open CL apt
RunInShell $setCLapt $CLapt_type $CLapt_before

# Refine vector param
Echo ===> Refining the vector
Call RefineVectors

If $skip_checkAccuracy == 0
   # Check multi-hole pattern
   If $grid_type != 0
      Echo ===> Check multihole pattern
      Call CheckMultiHole
   ElseIf $grid_type == 0
      Echo ===> Grid is lacey. Skip check multi-hole.
   Endif 
Endif 


# Set focus position
Echo ===> Set Focus and Trial Position
Call SetFocusTrialPosition

GoToLowDoseArea R
#GoToLowDoseArea V

# Reset CL apt
RunInShell $setCLapt $CLapt_type $CLapt_after

ScreenDown

If $show_navigation == 1
    If $CLapt_before != $CLapt_after
        OKBox Adjust CL aperture first.
    EndIf

    OKBox Run "AlignComaAndStig" before start data collection.

EndIf
EndMacro
Macro	11
ScriptName FindInitVectors

#===================================================================
# Script to figure out the hole spaceing initial parameter (distance and angle) of Quantifoil by using square image.
#     "TakeSquare" script must be run before running this script.
#     From SerialEM4.0, "AutoCorrPeakVectors" command can be used.
#     If you cannot use SerialEM4.0, please comment out "AutoCorrPeakVectors" and set "usePython = 1" below to use old python implementation.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Set "square_num = ". The corresponding square image (sq_num.jpg) in the "Squares" folder is used.
# 2. Just click "Run".
#     If it ran successfully and "usePython = 1", "02_VectorCandidates.png" is created in the session folder. It would be helpful to check the result.
#     "Vector_init_param.txt" is also created. It is used for the following "FindVectors" script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    # ============================
    # Parameters
    # ============================
    grid_type = 1 # 0: lacey, 1: quantifoil,UltrAufoil

    countThrd = 10
    scaleFactor = 1.2 # Normally 1. 

    # --- Parameters for non-lacey grid ---
    # ! Try to change this ---
    square_num = 0 #0 is default
    # ---------------------------

    # --- Use python or not ---
    usePython = 0 # 0: No, 1: Yes
    detector_type = 0 # Set Cameraproperty in SerialEMproperties.txt

    # ! Try to change this ---
    thresh = 0.01 # Threshold for peak search
    num_peaks = 16 # Number of peaks for peak search
    bin_factor = 1 # Binning factor to shrink image
    # ---------------------------

    # --- Parameters for lacey grid ---
    point_idx1 = 85
    point_idx2 = 86
    IS_spacing = 2 #[um] Spacing for Beam-Image shift
    max_IS_dist = 20 #[um] Maximum distance for Beam-Image shift

    # ============================
    # Main
    # ============================

    SuppressReports 
    CallFunction EMProperties::LoadAdditionalProperties

    If $usePython == 0
        CallFunction FindInitVectors::Core1 
    Else
        CallFunction FindInitVectors::Core2 $grid_type $point_idx1 $point_idx2 $IS_spacing $max_IS_dist $detector_type $square_num $thresh $num_peaks $bin_factor
    EndIf

#################################################

    # By SerialEM implemented
    Function Core1

        CloseFile 
        CallFunction EMProperties::LoadAdditionalProperties

        # Open image
        squareImages @= squares.mrc
        OpenOldFile $NAVIGATOR_PATH$squareImages 
        ReadFile $square_num A 

        # Get MagIndex info
        infoFile @= $NAVIGATOR_PATHSquaresJPG\sqJPG_info_$square_num.txt
        Echo $infoFile 
        Read2DTextFile arr2d $infoFile 
        magIndex = $arr2d[2][3]
        Echo MagIndex: $magIndex
     
        # Get image bin and pixel size
        ImageProperties A
        bin = $repVal3
        pixsize = $repVal5
        xsize = $repVal1
        ysize = $repVal2

        nxsize = NEARINT ( $xsize / 2 )
        nysize = NEARINT ( $ysize / 2 )

        minspacing = 999
        minangle = 0

        VEC_PEAK_DIR = $NAVIGATOR_PATHInitialVecPeaks
        RunInShell mkdir $VEC_PEAK_DIR

        # Search all image mean counts
        New2DArray imgArrs 0 0
        Loop 6 idd
            ReadFile $square_num A
            NewArray imageInfo 0 0
        
            If $idd == 1
                cropped_buf = O
                CropCenterToSize A $nxsize $nysize
            ElseIf $idd == 2
                cropped_buf = P
                CropImage A 0 $nxsize 0 $nysize
            ElseIf $idd == 3
                cropped_buf = Q
                CropImage A $nxsize $xsize 0 $nysize
            ElseIf $idd == 4
                cropped_buf = R
                CropImage A 0 $nxsize $nysize $ysize
            ElseIf $idd == 5
                cropped_buf = S
                CropImage A $nxsize $xsize $nysize $ysize
            Else 
                cropped_buf = T
            EndIf
            Copy A $cropped_buf
            ReportMeanCounts $cropped_buf
            meancounts = $repVal1

            If $meancounts < $countThrd
                Continue
            EndIf

            SaveToOtherFile $cropped_buf JPG NONE $VEC_PEAK_DIR\$idd_CropedImage.jpg

            AppendToArray imageInfo $meancounts
            AppendToArray imageInfo $cropped_buf
            AppendToArray imgArrs $imageInfo
        EndLoop

        If $#imgArrs == 0
            Echo Image is black. Cannot find the peak.
            Exit
        EndIf

        # Sort image by mean counts
        # ------ Sort array by mean counts -------
        If $#imgArrs > 1 
            change = 1
            searchRange = $#imgArrs - 1

            # psuedo while (change)
            Loop 9999999
                If $change == 0
                    Break
                EndIf

                change = 0
                Loop $searchRange i
                    If $imgArrs[$i][1] < $imgArrs[$i+1][1]
                        imgArrs_tmp = $imgArrs[$i]
                        imgArrs[$i] = $imgArrs[$i+1]
                        imgArrs[$i+1] = $imgArrs_tmp
                        change = 1
                    EndIf
                EndLoop
            EndLoop
        EndIf
        # ---------------------------------------------- 

        # Find cc peak for the best images
        New2DArray vecArrs 0 6 2
        Loop $#imgArrs jdx

            NewArray vecInfo 0 2
            # Get hole spacing parameters by pixel on camera
            AutoCorrPeakVectors $imgArrs[$jdx][2] $magIndex
            spacing = $repVal1 # [px]
            vecX = $repVal2 #[binned px]
            vecY = $repVal3 #[binned px]
            angle = ATAN2 ( $vecY $vecX )

            # SnapshotToFile 0 1 0 JPG NONE $VEC_PEAK_DIR\$idd_AutoCorrPeaks.jpg 

            # Convert from camera to specimen
            factor = 1
            If $useK2K3 == 1
                factor = 2
            EndIf 
            Xin = $vecX * $bin * $factor    # [unbinned px]
            Yin = $vecY * $bin * $factor * -1    # [unbinned px]

            CameraToSpecimenMatrix $magIndex
            XperX = $repVal1
            XperY = $repVal2
            YperX = $repVal3
            YperY = $repVal4

            X = $Xin * $XperX + $Yin * $XperY
            Y = $Xin * $YperX + $Yin * $YperY

            spacingOnSpec = SQRT ( $X * $X + $Y * $Y )
            angleOnSpec = ATAN2 ( $Y $X )

            # AppendToArray vecInfo $spacingOnSpec
            # AppendToArray vecInfo $angleOnSpec
            # AppendToArray vecArrs $vecInfo
            vecInfo[1] = $spacingOnSpec
            vecInfo[2] = $angleOnSpec
            vecArrs[$jdx] = $vecInfo

            #Echo $vecInfo
            Echo Try another area on the Square $square_num  ===>$jdx: On Specimen ===> Spacing: $spacingOnSpec (X: $X, Y: $Y) [um], Angle: $angleOnSpec [degree]

        EndLoop

        Space1 = round $vecArrs[1][1] 2
        Space2 = round $vecArrs[2][1] 2
        Space3 = round $vecArrs[3][1] 2
        Angle1 = round $vecArrs[1][2] 2
        Angle2 = round $vecArrs[2][2] 2
        Angle3 = round $vecArrs[3][2] 2

        header @= Choose the best multishot vector from the belowing:
        prompt1 @= Vector1: Lattice space is $Space1 um, Angle is $Angle1 degree
        prompt2 @= Vector2: Lattice space is $Space2 um, Angle is $Angle2 degree
        prompt3 @= Vector3: Lattice space is $Space3 um, Angle is $Angle3 degree
        buttons = { Vector1 Vector2 Vector3 }
        ThreeChoiceBox header prompt1 prompt2 prompt3 buttons
        selectedIdx =  $repVal1
        
        # Maybe fix here
        bestSpacing = $vecArrs[$selectedIdx][1] * $scaleFactor
        bestAngle = $vecArrs[$selectedIdx][2]

        #Echo +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        Echo Expected spacing are here
        Echo On Specimen ===> Spacing: $bestSpacing [um], Angle: $bestAngle [degree] 
        RunInShell echo $bestSpacing $bestAngle > $NAVIGATOR_PATHVector_init_param.txt
        Echo Saved as $NAVIGATOR_PATHVector_init_param.txt

        CloseFile 

     EndFunction

#################################################

    # By Python implemented
    Function Core2 10 0 grid_type point_idx1 point_idx2 IS_spacing max_IS_dist detector_type square_num thresh num_peaks bin_factor

        # Initialize
        SuppressReports 
        path_to_propertyFile = C:\ProgramData\SerialEM\SerialEMproperties.txt

        ReportNavFile 1
        NAVIGATOR_PATH = $repVal3

        If $grid_type == 1 	
            Echo $cmd_findV $detector_type $square_num $thresh $num_peaks $bin_factor $path_to_propertyFile $NAVIGATOR_PATH
            RunInShell $cmd_findV $detector_type $square_num $thresh $num_peaks $bin_factor $path_to_propertyFile $NAVIGATOR_PATH
        Else
            ReportOtherItem $point_idx1
            x1 = $repVal2
            y1 = $repVal3

            ReportOtherItem $point_idx2
            x2 = $repVal2
            y2 = $repVal3

            x = $x2 - $x1
            y = $y2 - $y1

            dist = sqrt ( $x * $x + $y * $y )
            radius = $IS_spacing
            angle = ATAN2 ( $y $x )

            RunInShell echo $radius $angle > $NAVIGATOR_PATHVector_init_param.txt

            half_width = $dist / 2
            If $half_width <= $max_IS_dist
                layer = NEARINT ( $half_width / $radius - 0.5 )
            Else
                layer = NEARINT ( $max_IS_dist / $radius - 0.5 )
            EndIf

            Echo ===========================
            Echo Distance between two stage points : $dist [um]
            Echo Radius for MultiHole : $radius [um]
            Echo Angle for MultiHole: $angle [degree]
            Echo Maximum layer : $layer
            Echo ===========================
            
            RunInShell echo $layer > $NAVIGATOR_PATHLacey_layer.txt

        EndIf

    EndFunction

#################################################
EndMacro
Macro	12
ScriptName RefineVectors

#===================================================================
# Script for refining the hole spaceing parameter.
#     LowDoseMode must be set up before running this script.
#     "FindInitVectors" script should be run in advance unless you set the initial parameter manually.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Adjust Z height to -10um or -20um.
# 2. Move to the hole center.
# 3. "Run" this script.
#     It will output "Vectors_ViewMode.txt" and "Vectors_RecordMode.txt" in the session folder. 
#     Both are used for "CheckMultiHole" script. "Vectors_RecordMode.txt" is used for the data collection.
# --------------------------------------------------------------------------------------------------------------------
# Originally made for CryoARM300 in Akishima by T.Kato and F.Makino
# Modified by TF and FM.
#===================================================================

    # ============================
    # Parameters
    # ============================
    grid_type = 1 # 0: lacey, 1: quantifoil,UltrAufoil
    exposure_time = 3 #[sec]
    open_slit = 0 # Open slit anyway when FindVector. 0:No 1:Yes
    spacingNum = 1 # Number of hole spacing for the refinement.
    iter_num = 2 # Number of refinement iteration
    use_eucentirc_focus = 0 #1:yes, 0:no, use eucentric focus when 

    # ------- For manual setting -------
    manual = 0 # 0:No, 1:Yes
    holeDistance = 2.5    # Distance between each holes [um]
    holeAngle = -4    # Angle between X-axis of "Stage" and X-axis of "hole lattice" (or Y) [degree]
    # ------------------------------------------

    # ============================
    # Main
    # ============================

    CallFunction EMProperties::LoadAdditionalProperties
    CallFunction RefineVectors::Core $grid_type $exposure_time $manual $holeDistance $holeAngle

    # Set vectors in setting file
    Echo ===> Set vectors in setting file

#################################################

    Function Core 5 0 grid_type exposure_time manual holeDistance holeAngle

        SuppressReports 
        ReportNavFile 1
        NAVIGATOR_PATH = $repVal3

        If $manual == 0
            ReadTextFile vector $NAVIGATOR_PATHVector_init_param.txt
            holeDistance = $vector[1]
            holeAngle = $vector[2]
        EndIf

        SetImageShift 0 0 0 0

        GoToLowDoseArea V
        SaveFocus

        If $open_slit == 1
            CallFunction Funcs::CustomSetSlitIn 0
        EndIf

        UpdateLowDoseParams V

        If $use_eucentirc_focus == 1
           SetEucentricFocus
        Endif 
        # Set camera params
        SetExposure V $exposure_time

        # Set central IS
        ReportImageShift
        ISX0 = $RepVal1
        ISY0 = $RepVal2
        Echo $holeDistance, $holeAngle

        # Acquire first image for the template
        If $grid_type != 0
            V
            Copy A P
        EndIf

        # --- Refine vector 1 ---
        Echo ===== Start refinement for the first vector =====
        CallFunction RefineVectors::RefineOneDirection $holeDistance $holeAngle
        dist1_view = $repVal1
        angle1_view = $repVal2
        dist1_rec = $repVal3
        angle1_rec = $repVal4
        IS_X1_gny = $repVal5
        IS_Y1_gny = $repVal6

        # --- Refine vector 2 ---
        Echo ===== Start refinement for the second vector =====
        holeAngle = $holeAngle + 90
        CallFunction RefineVectors::RefineOneDirection $holeDistance $holeAngle
        dist2_view = $repVal1
        angle2_view = $repVal2
        dist2_rec = $repVal3
        angle2_rec = $repVal4
        IS_X2_gny = $repVal5
        IS_Y2_gny = $repVal6   

        RunInShell echo $dist1_view $angle1_view $dist2_view $angle2_view > $NAVIGATOR_PATHVectors_ViewMode.txt
        RunInShell echo $dist1_rec $angle1_rec $dist2_rec $angle2_rec > $NAVIGATOR_PATHVectors_RecordMode.txt
        RunInShell echo $IS_X1_gny $IS_Y1_gny $IS_X2_gny $IS_Y2_gny > $NAVIGATOR_PATHVectors_RecordMode_IS.txt

        # Reset View parameters
        GoToLowDoseArea V
        RestoreFocus
        RestoreLowDoseParams V
        SetImageShift 0 0 0 0

        # Reset camera params for View
        RestoreCameraSet V

        RunInShell echo $grid_type > $NAVIGATOR_PATHGrid_type.txt

        Echo Finish.
        Echo Result was save in...
        Echo $NAVIGATOR_PATHVectors_ViewMode.txt
        Echo $NAVIGATOR_PATHVectors_RecordMode.txt
        Echo $NAVIGATOR_PATHVectors_RecordMode_IS.txt
    EndFunction

#################################################

    Function RefineOneDirection 2 0 hole_distance hole_angle

        holeDistanceView = $hole_distance * $spacingNum
        holeAngleView = $hole_angle

        Loop $iter_num icount
            GoToLowDoseArea V
            IS_X = $holeDistanceView * cos ($holeAngleView)
            IS_Y = $holeDistanceView * sin ($holeAngleView)
            ImageShiftByMicrons $IS_X $IS_Y 0 0
            Delay 1 sec
            
            If $grid_type != 0
               Echo ===> Refinement iterration $icount
               V
               AlignTo P
            EndIf
            
            ReportSpecimenShift IS_Xn IS_Yn

            echo  IS_Xn, IS_Yn = $IS_Xn, $IS_Yn
            holeAngleView = ATAN2 ( $IS_Yn $IS_Xn )
            holeDistanceView  = sqrt ($IS_Xn * $IS_Xn + $IS_Yn * $IS_Yn)

            If $icount == $iter_num
                GoToLowDoseArea R
                Delay 1 sec
                ReportSpecimenShift IS_Xn IS_Yn
                ReportImageShift IS_Xn_gny IS_Yn_gny
                holeAngleRec = ATAN2 ( $IS_Yn $IS_Xn )
                holeDistanceRec  = sqrt ($IS_Xn * $IS_Xn + $IS_Yn * $IS_Yn)
            EndIf

            SetImageShift $ISX0 $ISY0
        EndLoop

        holeDistanceView = ( $holeDistanceView + 0.0001 ) / $spacingNum
        holeDistanceRec = ( $holeDistanceRec + 0.0001 ) / $spacingNum
        IS_Xn_gny = $IS_Xn_gny / $spacingNum
        IS_Yn_gny = $IS_Yn_gny / $spacingNum

        Echo ---------------------------------------
        Echo At View mode
        Echo Refined hole distance [um] : $holeDistanceView
        Echo Refined hole angle [degree] : $holeAngleView 
        Echo 
        Echo At Record mode
        Echo Refined hole distance [um] : $holeDistanceRec
        Echo Refined hole angle [degree] : $holeAngleRec 
        Echo ---------------------------------------

        Return $holeDistanceView $holeAngleView $holeDistanceRec $holeAngleRec $IS_Xn_gny $IS_Yn_gny

    EndFunction

#################################################
EndMacro
Macro	13
ScriptName CheckMultiHole

#===================================================================
# Script to confirm the "FindVectors" resutlt is correct.
#     LowDoseMode must be set up before running this script.
#     "FindVectors" script must be run in advance.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Adjust Z heght.
# 2. Move to the center of the hole.
# 3. If you would like to perform multiple-shot in a hole. 
#     Please set "Multiple Record Setup" from "Navigator > Montaging&Grids > Set Multi-shot parameters...".
#     And "use_multiR = 1" below. 
# 4. "Run" this script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    # =================
    # Parameters
    # =================
    # Use SerialEM implemented multiple Record setting?
    use_multiR = 0 # 0:No, 1:Use only multi-shot setting, 2: Use both multiple-shot and multiple-hole setting

    #! If you use SerialEM implemented, below parameters are ignored.
    # 0:View, 1:Record
    LD_mode = 0

    # For multi-hole by IS()
    # 0:even, 1:odd
    PATTERN = 1 
    # For  odd LAYER => 1: 3x3, 2: 5x5, 3: 7x7, ...
    # For even LAYER => 1: 2x2, 2: 4x4, 3: 6x6, ...
    LAYER = 1

    # Active BT comp
    BTtoIS = 0 # 0:No, 1:Yes
    
    # For tilt
    tilt_angle = 0 #[degree]

    # Other parameters
    check_coma = 0 #0:No, 1:Yes
    apply_defocus_offset = 1 #0:No, 1:Yes, it doesn't work now...
    defocus_offset = 0 #[um]
    apply_seteucentricfocus = 0 #0:No, 1:Yes

    # Set offset for a shot
    use_offshot = 0 # 0:No, 1:Yes
    n2x = 0.0 #[um] along Tilt axis,+ below, - upper
    n2y = 0.0 #0.42 #[um] + right, - left

    # Set TargetTilt (TT) and frequency 
    do_tilt = 0 # 0:No, 1:Yes
    TT_list = { 0 10 20 30 40 } # [degree]
    TT_freq = { 0 2 1 0 1 }

    acquired_image_num := 1 #???

    # =================
    # Initialize
    # =================

    CallFunction EMProperties::LoadAdditionalProperties
    
    SetLowDoseMode 1

    RunInShell mkdir $NAVIGATOR_PATHCheckMultiHole

    If $use_multiR != 0
        BTtoIS = 0
    EndIf

    If $LD_mode == 0
       GoToLowDoseArea V
       SaveFocus 
       ReadTextFile vector $NAVIGATOR_PATHVectors_ViewMode.txt
       If $apply_seteucentricfocus == 1
          SetEucentricFocus 
       Endif 
       CallFunction Funcs::CustomReportEnergyFilter 
       initailslit_status = $repVal3
       CallFunction Funcs::CustomSetSlitIn 0
       UpdateLowDoseParams V
    ElseIf $LD_mode == 1
       GoToLowDoseArea R
       #SaveFocus 
       ReadTextFile vector $NAVIGATOR_PATHVectors_RecordMode.txt
    EndIf

    # For multi-hole
    IS_RAD1_h = $vector[1]
    IniAng_h = $vector[2]
    IS_RAD1_v = $vector[3]
    IniAng_v = $vector[4]
    Echo ===> Horivontal : $IS_RAD1_h $IniAng_h 
    Echo ===> Vertical : $IS_RAD1_v $IniAng_v 

    TT = $tilt_angle

    # =================
    # Main 
    # =================

    ReportBeamTilt btx_base bty_base
    Echo ===> Initial BT ($btx_base, $bty_base)

    cnt = 0
    CallFunction ImageAcquisition::AquireMultiHoles

    RestoreFocus
    If $LD_mode == 0
        CallFunction Funcs::CustomSetSlitIn $initailslit_status
        UpdateLowDoseParams V
    EndIf

    SetBeamTilt $btx_base $bty_base
    ReportBeamTilt btx_last bty_last
    Echo ===> last BT ($btx_last $bty_last)
EndMacro
Macro	14
ScriptName SetFocusTrialPosition

#===================================================================
# Script to set the Focus and Trial mode position. 
#     Trial mode is used for the beam centering during the data collection.
#     They are set on the carbon area of the quantifoil.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# Just lick "Run" if you have already run "TakeSquares" script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

# ============================
# Main
# ============================

SuppressReports 

ReportNavFile 1
NAVIGATOR_PATH = $repVal3
vector_file = $NAVIGATOR_PATHVectors_ViewMode.txt
init_vector_file = $NAVIGATOR_PATHVector_init_param.txt
    
# Try to open/read Vectors_ViewMode.txt
open_agin = 0

Try
   ReadTextFile vector $vector_file
   IS_RAD1_h   = $vector[1]
   IniAng_h    = $vector[2]
   IS_RAD1_v   = $vector[3]
   IniAng_v    = $vector[4]
   dist = ($IS_RAD1_h + $IS_RAD1_v) / 2
   dist = $dist * SQRT (2) / 2
   angle = ($IniAng_h + $IniAng_v) / 2
   angle = MODULO ($angle  90)

   #Echo ===> Read $vector_file
   Echo ===> Dist : $dist [um], Angle : $angle [degree]

Catch 
   Echo ===> Cannot find $vector_file
   Echo ===> Try to open $init_vector_file
   open_agin = 1
EndTry 

# Try to open/read Vector_init_param.txt

If $open_agin == 1
    Loop 2 idx
        Try 
            ReadTextFile vector $init_vector_file
            IS_RADIUS = $vector[1]
            IS_ANGLE = $vector[2]
            dist = $IS_RADIUS * SQRT (2) / 2
            angle_tmp = $IS_ANGLE + 45
            angle = MODULO ($angle_tmp 90)
            Break 
        Catch
            Echo ===> No vector info...
            Echo ===> Need to run "FindInitVectors" or "FindVectors" beforehand.
            Echo ===> Run automatically.
            Call FindInitVectors
        EndTry

        If $idx == 2
            Echo ===> Program failed.
            Return
        EndIf
    EndLoop 
Endif 



SetLowDoseMode 1
GoToLowDoseArea R
GoToLowDoseArea V

SetAxisPosition F $dist $angle
SetAxisPosition T $dist $angle

RunInShell echo $dist $angle > $NAVIGATOR_PATHFocusTrialPosition.txt
EndMacro
Macro	16
ScriptName AlignComaAndStig

#===================================================================
# Script for coma-free alignment and OL astigmatism correction.
#     It is better to run this script just before data collection.
#     LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Move stage to carbon area. This script will not work on UltrAuFoil.
# 2. Roughly Adjust Z heght.
# 3. If the rotational center is far way off. Align rotational center.
# 4. "Run" this scrpt.
# ---------------------------------------------------c-----------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    # ============================
    # Parameters
    # ============================
    # Set settling time
    settle_time = 10 #[sec]
    exp_time = 1 #[sec]

    target_defocus = -1.4

    do_ZLPrefine = 0 # 0:No, 1:Yes, 2: Popup dialog box
    area = R # Area for ZLP alignment
    do_beam_centering = 0 # 0:No, 1:Yes, 2: Popup dialog box

    setOLaptAtLast = 0 # 0: No, 1,2,3,4: OLapt number
    call_z_byV = 0  # 0:No, 1:Yes
    
    # ============================
    # Main
    # ============================
    CallFunction EMProperties::LoadAdditionalProperties

    SetColumnOrGunValve 1

    # Make sure you are on carbon area
    GoToLowDoseArea V
    ResetImageShift 
    V
    YesNoBox Are you on carbon area?
    If $repVal1 == 0
       OKBox Move stage to the carbon area. And double check the beam stauts.
       Exit
    EndIf

    If $call_z_byV == 1
       # Z by V first
       Call Z_byV
    Endif 
    # ====== Set parameters ======
    GoToLowDoseArea R    
    ReportBeamTilt btx_init bty_init
    Echo ===> Initial Beam-Tilt ( BTx: $btx_init, BTy: $bty_init )

    SetExposure R $exp_time 
    SetBinning R 2
    SetDoseFracParams R 0 0 0 0 0
   
    # Remove OL apt
    RunInShell $setOLapt $OLapt_type 0

    SetTargetDefocus $target_defocus
    updata_Z_afterFocus = 0


    # -------- Auto focus on Record mode --------
    focus_method = 1 # 0: Z and OL, 1: Z
    focus_error = 0.4 #[um]
    settle_time = 999 #[sec]
    max_focusZ_iter = 999
    max_focus_iter = 999
    z_settle_time = 999
    OLFocusLimit = 999 #[um]]
    focus_th_low = 999 #[um]
    focusOnRec = 1 # 0: Focus, 1: Record, -1: Default

    CallFunction CustomAutoFocus::AutoFocus_byZ
    # -----------------------------------------------------------

    RestoreCameraSet R

    # ====== Refine ZLP ======
    
    apply_refine_ZLP = 0
    If $do_ZLPrefine == 0
        apply_refine_ZLP = 0
    ElseIf $do_ZLPrefine == 1
        apply_refine_ZLP = 1
    ElseIf $do_ZLPrefine == 2
        YesNoBox Refine ZLP by FL?
         If $repVal1 == 1
             apply_refine_ZLP = 1
         EndIf
    EndIf

    If $apply_refine_ZLP == 1
        Echo ===> Apply Refine ZLP
        CallFunction Funcs::CustomSetSlitIn 1
        UpdateLowDoseParams R 1
        ReportTickTime start_time_ZLP
        Call ZLPAlignByFL
        ReportTickTime end_time_ZLP
        settle_time = $settle_time - ($end_time_ZLP $start_time_ZLP)
        If $settle_time <= 0
            settle_time = 0
        EndIf
        Echo ===> Waiting for settling $settle_time [sec]   
    Else
        Echo ===> Do not apply Refine ZLP
        Echo ===> Waiting for settling $settle_time [sec]
    EndIf

    # ====== AlignComa and Stig ======

    Delay $settle_time sec

    SetExposure R 1.0
    SetBinning R 2
    SetDoseFracParams R 0 0 0 0 0

    Try
        FixComaByCTF
        FixAstigmatismByCTF
        FixAstigmatismByCTF
    Catch
        Echo ===> Fail to fit CTF. Skip coma-free alignment.
        Echo ===> Check rotational center manually and set larger BT% at  "Set CTF Coma-free Param" in "Focus/Tune".
    EndTry

    RestoreCameraSet R
    SetEucentricFocus

    ReportBeamTilt btx_aligned bty_aligned
    Echo ===> Beam-Tilt aligned to ( BTx: $btx_aligned, BTy: $bty_aligned )

    # Normalize LowDoseMode
    Echo ===> Normalizing LowDoseMode
    Loop 1
        GoToLowDoseArea V
        Delay 0.5 sec
        GoToLowDoseArea T
        Delay 0.5 sec
        GoToLowDoseArea F
        Delay 0.5 sec
        GoToLowDoseArea R
        Delay 0.5 sec
        GoToLowDoseArea V
        Delay 0.5 sec
    EndLoop

    Echo ===> Finish Coma-free alignment

    # ====== Beam Centering ======

    apply_beam_centering = 0
    If $do_beam_centering == 0
        apply_beam_centering = 0
    ElseIf $do_beam_centering == 1
        apply_beam_centering = 1
    ElseIf $do_beam_centering == 2
        YesNoBox Do Beam Centering?
        If $repVal1 == 1
            apply_beam_centering = 1
        EndIf
    EndIf

    If $apply_beam_centering == 1
        GoToLowDoseArea T
        T
        ReportMeanCounts A
        mean_count = $repVal1
        If $mean_count > 10
            ReportBeamShift init_beamX init_BeamY
            Echo ---> BeamCentering...
            T
            CenterBeamFromImage
            T
            ReportMeanCounts A
            mean_count = $repVal1

            If $mean_count < 10
                Echo ---> Beam Centering failed... Reset BeamShift.
                SetBeamShift $init_beamX $init_BeamY
            EndIf
        EndIf

        GoToLowDoseArea F
        GoToLowDoseArea R
        GoToLowDoseArea V
    EndIf

    # Set OL apt
    RunInShell $setOLapt $OLapt_type $setOLaptAtLast 
    OKBox Finished. Please set the folder for saving movies, double check the beam status and then start collection.
EndMacro
Macro	18
ScriptName Parameters_Screening

#===================================================================
# Setting for "SPADataCollection" script. 
# It will be loaded while "SPADataCollection" is running.
# --------------------------------------------------------------------------------------------------------------------
# Made for CryoARM300 in Osaka.U by F.Makino
#===================================================================

##################################################################
# General parameters
##################################################################

    #====================================================
    # Focus
    #====================================================
    focus_method = 0 # 0: Z and OL, 1: Only Z

    # Set TargetDefocus(TD) range and step.
    TD_low  = -2 #[um]
    TD_high = -3 #[um]
    TD_step = 0.2 #[um]

    #====================================================
    # Tilt 
    #====================================================
    # Set TargetTilt (TT) and frequency 
    do_tilt = 0 # 0:No, 1:Yes
    TT_list = { 0 10 20 30 40 } # [degree]
    TT_freq = { 0 2 1 0 1 }


    #====================================================
    # Record
    #====================================================
    # Set offset for a shot
    use_offshot = 0 # 0:No, 1:Yes
    n2x = 0.0 #[um] along Tilt axis,+ below, - upper
    n2y = -0.43 #0.0 #[um] - left, + right


##################################################################
# Advanced setting parameters
##################################################################

    #====================================================
    # Flashing, Dark Reference and Refill
    #====================================================
    # C-FEG flashing 
    FlashInterval := 6 * 3600 #[hrs x 3600]
    #FlashInterval := 0.05 * 3600 # 3min for test

    # Dark reference for K2/K3
    update_dark = 1 # 0:No, 1:Yes
    DarkRefInterval := 6 * 3600 #[hrs x 3600]

    # Refill
    flash_when_refill := 1
    darkRef_when_refill := 0
    delay_after_refill = 3 # [min]

    #====================================================
    # ZLP centering
    #====================================================
    do_refineZLP = 1 # 0:No, 1:Yes
    ZLPInterval  := 12 * 3600 #[hrs x 3600]
    #ZLPInterval  := 0.05 * 3600 #[hrs x 3600] # 3min for test

    search_range = 40 # [step]. If set 40, range from -20 to +20.
    search_step = 1 # [step]
    ZLP_thld_ratio = 0.7
    area = R # Area for ZLP alignment
    ZLP_when_flash = 0 # Flashing after ZLP refinement?, 0:No, 1:Yes

    #====================================================
    # Hole Alignment
    #====================================================
    # use YoneoLocker?
    use_YL = 0 #0: No, 1:Yes

    # Adjust Z before hole alignmnet? Once each groups.
    do_Z_byV = 0 #0: No, 1:Yes

    # Template buffer for hole alignment
    template_buffer = T

    #! Screening
    # Threshold for realigning to hole by stage
    maxholeshift = 0.2 * 1000 #[um x 1000] 

    # Maximum iteration for hole alignment
    max_align_iter = 10

    #! Screening
    # Use IS for final alignment?
    align_byIS = 0 # 0:No, 1:Yes

    #! Screening
    # Always realign to hole before taking record?
    realignBeforeRecord = 1 #0: No, 1:Yes

    # If yes, stop hole alignment after Focusing and Drift control. Cancels "realignBeforeRecord". 
    stop_hole_realign = 0 # 0:No, 1:Yes

    #====================================================
    # Drift control
    #====================================================
    # Do drift control?
    do_drift_control = 1 # 0:No, 1:Yes
    use_focus_drift = 1 # 0:No, 1:Yes
    once_every_group = 1 # 0:No, 1:Yes
    drift_ctrl_when_tilt = 1 # 0:No, 1:Yes (If yes, always drift control after tilt)
    tilt_settling_time = 0 # [sec], additional settling time after stage tilt

    # Drift rate threshold [A/sec], only get used for skip = 0
    drift_crit = 5 #[A/sec]
    drift_shot = F

    # Move opposit direction while waiting drift ?
    resist_drift = 1 # 0:No, 1:Yes

    additional_settling_time = 0 #[sec]

    #====================================================
    # Focus
    #====================================================
    # Autofocus error
    focus_error = 0.2 #[um] #0.2

    # When the stage moves following distance, then autofocus.
    stageX_limit_for_focus = 50 #[um]
    stageY_limit_for_focus = 50 #[um]
    stageZ_limit_for_focus = 5 #[um]

    # Define, how often the microscope should focus: 
    # focusEachHole := 0   means to keep focus target constant and focus always.
    # focusEachHole := 1   means to increment focus target and focus always.
    # focusEachHole := 5   means to increment focus target and focus only every 5th image.
    focusEachHole := 0

    # Define, how often the microscope should do beam centering: 
    beamCenterEachHole = 2

    # Irradiation for focus
    irradiation_time = 0 #[sec]

    # Skip BeamCentering when auto focus is NOT performed
    skip_BeamCentering = 1 # 0:No, 1:Yes
    beamCentering_afterFocus = 0 # 0:No, 1:Yes

    # Update group Z after Focus?
    updata_Z_afterFocus = 1 # 0:No, 1:Yes   

    # Focus error value. 999 for default
    focus_error = 999 #[um]

    # Settling time after finishing focus. 999 for default.
    settle_time = 999 #[sec]

    # Maximum iterration number of Z focusing. 999 for default.    
    max_focusZ_iter = 999

    # Maximum iterration number of OL focusing. 999 for default.   
    max_focus_iter = 999

    # Settling time when changing Z during the iterration. 999 for default.
    z_settle_time = 999

    # OL focusing is applied up to "OLFocusLimit ", otherwize Z adjustment is used for the large focusing. 999 for default.
    OLFocusLimit = 999 #[um]

    # Lowest focus threshold. 999 for default.
    focus_th_low = 999 #[um]

    # Focusing area.
    focusOnRec = -1 # 0: Focus, 1: Record, -1: Default

    #====================================================
    # Record
    #====================================================
    # --- Use SerialEM based multiple Record? ---
    use_multiR = 0 # 0:No, 1:Use only multi-shot setting, 2: Use both multiple-shot and multiple-hole setting

    # --- Use Script based multiple Record? ---
    # For script based multiple-hole 
    PATTERN = 1  # 0:even, 1:odd
    LAYER = 0  # odd LAYER => 1: 3x3, 2: 5x5, 3: 7x7, ...    # even LAYER => 1: 2x2, 2: 4x4, 3: 6x6, ... # 0 => single shot

    # For Acceptance test
    R_delay = 0 # [sec]

    # Measure thickness? (Only availavle when PATTERN = 1)
    measure_thickness = 1 # 0:No, 1:Yes

    #====================================================
    # Active Beam-Tilt Compensation
    #====================================================
    # Perform BT(BeamTilt) compensation? (Use SerialEM implemented)
    BTtoIS = 1 # 0:No, 1:Yes

    #====================================================
    # Tilt 
    #====================================================
    changeTT_byFlashing = 1 # 0:No 1:Yes

    focus_before_tilt = 1 # 0:No 1:Yes, Focusing by Z "before tilting".
    use_eucentric_height = 0 # 0:No 1:Yes, Adjust Z to eucentric height "before tilting".

    max_track_shift = 3000 #[nm]
    stop_OLfocusing = 0 # 0:No 1:Yes, Stop focusing by OL "after tilting" anyway (For NIH claiming)

    #====================================================
    # Phase Plate Setting
    #====================================================
    use_PhasePlate = 0 # 0:No, 1:Yes
    use_ConditionSetup = 1 # 0:No, 1:Yes, Use setting from "Phase Plate Condtioning Setup dialog"

    # If use_ConditionSetup is 1, below setting are ignored.
    PP_interval_images = 60 #[images]
    PP_drift_wait_time = 3 #[min]
    PP_charge_up_time = 1 #[min]

    #====================================================
    # Display Setting
    #====================================================  
    stop_display_R = 0 # 0:display, 1:stop display

    # Just for "EarlyReturnNextShot".
    # This is for no return for Record Frame exposure for a K2/K3 camera.
    noReturn = -1
 
    # How often do you want to show images?
    # If you want to see the recorded image for every movie (DisplayOnly=1) or 
    # only for every 10th movie (DisplayOnly=10) or even more rarely:
    DisplayOnly = 1000

    #====================================================
    # LogImage Setting
    #====================================================  
    save_V = 1 # 0:No, 1:Yes
    save_T = 1 # 0:No, 1:Yes
    save_F = 1 # 0:No, 1:Yes
    save_R = 1 # 0:No, 1:Yes
    savelognewfile = 0 # 0:No, 1:Yes
Echo ---> Calling Parameters_Screening ...
EndMacro
Macro	19
ScriptName SPADataCollection_Screening

#===================================================================
# Main script for the SPA data collection.
#===================================================================

workflowType = 2 # 0: Other task, 1: Data collection, 2: Screening

CallFunction SPADataCollection::Core $workflowType 
EndMacro
Macro	20
ScriptName Parameters

#===================================================================
# Setting for "SPADataCollection" script. 
# It will be loaded while "SPADataCollection" is running.
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion repository.
# Modified by TF and FM.
#===================================================================

##################################################################
# General parameters
##################################################################

    #====================================================
    # Focus
    #====================================================
    focus_method = 0 # 0: Z and OL, 1: Only Z

    # Set TargetDefocus(TD) range and step.
    TD_low  = -1.0 #[um]
    TD_high = -2.0 #[um]
    TD_step = 0.1 #[um]

    #====================================================
    # Record
    #====================================================
    # --- Use SerialEM based multiple Record? ---
    # Basically always use 1.
    use_multiR = 1 # 0:No, 1:Use only multi-shot setting, 2: Use both multiple-shot and multiple-hole setting

    LAYER = 2  # odd LAYER => 1: 3x3, 2: 5x5, 3: 7x7, ...    # even LAYER => 1: 2x2, 2: 4x4, 3: 6x6, ... # 0 => single shot

    #====================================================
    # Tilt 
    #====================================================
    # Set TargetTilt (TT) and frequency 
    do_tilt = 0 # 0:No, 1:Yes
    TT_list = { 0 10 20 30 40 } # [degree]
    TT_freq = { 1 0 2 1 0 }



    #====================================================
    # Record
    #====================================================
    # Set offset for a shot
    use_offshot = 0 # 0:No, 1:Yes
    n2x = 0.0 #[um]
    n2y = 0.0 #[um]


##################################################################
# Advanced setting parameters
##################################################################

    #====================================================
    # Flashing, Dark Reference and Refill
    #====================================================
    # C-FEG flashing 
    FlashInterval := 6 * 3600 #[hrs x 3600]
    #FlashInterval := 0.05 * 3600 # 3min for test

    # Dark reference for K2/K3
    update_dark = 0 # 0:No, 1:Yes
    DarkRefInterval := 6 * 3600 #[hrs x 3600]

    # Refill
    flash_when_refill := 1
    darkRef_when_refill := 0
    delay_after_refill = 3 # [min]

    #====================================================
    # ZLP centering
    #====================================================
    do_refineZLP = 1 # 0:No, 1:Yes
    ZLPInterval  := 4 * 3600 #[hrs x 3600]
    #ZLPInterval  := 0.05 * 3600 #[hrs x 3600] # 3min for test

    search_range = 40 # [step]. If set 40, range from -20 to +20.
    search_step = 1 # [step]
    ZLP_thld_ratio = 0.7
    area = R # Area for ZLP alignment
    ZLP_when_flash = 0 # Flashing after ZLP refinement?, 0:No, 1:Yes

    #====================================================
    # Hole Alignment
    #====================================================
    # use YoneoLocker?
    use_YL = 1 #0: No, 1:Yes

    # Adjust Z before hole alignmnet? Once each groups.
    do_Z_byV = 0 #0: No, 1:Yes

    # Template buffer for hole alignment
    template_buffer = T

    # Threshold for realigning to hole by stage
    maxholeshift = 0.15 * 1000 #[um x 1000] , 0.25 for highthroughtput

    # Maximum iteration for hole alignment
    max_align_iter = 10

    # Always realign to hole before taking record?
    realignBeforeRecord = 1 #0: No, 1:Yes

    # Use IS for the final alignment?
    align_byIS = 1 # 0:No, 1:Yes, 1 for highthroughtput

    # If yes, stop hole alignment after Focusing and Drift control. Cancels "realignBeforeRecord". 
    stop_hole_realign = 0 # 0:No, 1:Yes

    #====================================================
    # Drift control
    #====================================================
    # Do drift control?
    do_drift_control = 1 # 0:No, 1:Yes
    use_focus_drift = 1 # 0:No, 1:Yes
    once_every_group = 1 # 0:No, 1:Yes
    drift_ctrl_when_tilt = 1 # 0:No, 1:Yes (If yes, always drift control after tilt)
    tilt_settling_time = 0 # [sec], additional settling time after stage tilt

    # Drift rate threshold [A/sec], only get used for skip = 0
    drift_crit = 5 #[A/sec]
    drift_shot = F

    # Move opposit direction while waiting drift ?
    resist_drift = 0 # 0:No, 1:Yes

    additional_settling_time = 0 #[sec]

    #====================================================
    # Focus
    #====================================================
    # Autofocus error
    focus_error = 0.3 #[um] #0.2

    # When the stage moves following distance, then autofocus.
    stageX_limit_for_focus = 50 #[um]
    stageY_limit_for_focus = 50 #[um]
    stageZ_limit_for_focus = 5 #[um]

    # Define, how often the microscope should focus: 
    # focusEachHole := 0   means to keep focus target constant and focus always.
    # focusEachHole := 1   means to increment focus target and focus always.
    # focusEachHole := 5   means to increment focus target and focus only every 5th image.
    focusEachHole := 0

    # Define, how often the microscope should do beam centering: 
    beamCenterEachHole = 3

    # Irradiation for focus
    irradiation_time = 0 #[sec]

    # Skip BeamCentering when auto focus is NOT performed
    skip_BeamCentering = 1 # 0:No, 1:Yes
    beamCentering_afterFocus = 0 # 0:No, 1:Yes

    # Update group Z after Focus?
    updata_Z_afterFocus = 1 # 0:No, 1:Yes   

    # Focus error value. 999 for default
    focus_error = 999 #[um]

    # Settling time after finishing focus. 999 for default.
    settle_time = 999 #[sec]

    # Maximum iterration number of Z focusing. 999 for default.    
    max_focusZ_iter = 999

    # Maximum iterration number of OL focusing. 999 for default.   
    max_focus_iter = 999

    # Settling time when changing Z during the iterration. 999 for default.
    z_settle_time = 999

    # OL focusing is applied up to "OLFocusLimit ", otherwize Z adjustment is used for the large focusing. 999 for default.
    OLFocusLimit = 999 #[um]

    # Lowest focus threshold. 999 for default.
    focus_th_low = 999 #[um]

    # Focusing area.
    focusOnRec = -1 # 0: Focus, 1: Record, -1: Default

    #====================================================
    # Record
    #====================================================
    # --- Use Script based multiple Record? ---
    PATTERN = 1  # 0:even, 1:odd

    # Measure thickness? (Only availavle when PATTERN = 1)
    measure_thickness = 0 # 0:No, 1:Yes

    # For Acceptance test
    R_delay = 0 # [sec]

    # +++ This parameter is not used anymore. Will delete in the future. +++
    # If set to 1, IS is always 0 at center of multi-hole pattern
    zero_IS = 0 # 0:No, 1:Yes

    #====================================================
    # Active Beam-Tilt Compensation
    #====================================================
    # Perform BT(BeamTilt) compensation? (Use SerialEM implemented)
    BTtoIS = 1 # 0:No, 1:Yes
    
    #====================================================
    # Tilt 
    #====================================================
    changeTT_byFlashing = 0 # 0:No 1:Yes

    focus_before_tilt = 1 # 0:No 1:Yes, Focusing by Z "before tilting".
    use_eucentric_height = 0 # 0:No 1:Yes, Adjust Z to eucentric height "before tilting".

    max_track_shift = 3000 #[nm]
    stop_OLfocusing = 0 # 0:No 1:Yes, Stop focusing by OL "after tilting" anyway (For NIH claiming)

    #====================================================
    # Phase Plate Setting
    #====================================================
    use_PhasePlate = 0 # 0:No, 1:Yes
    use_ConditionSetup = 1 # 0:No, 1:Yes, Use setting from "Phase Plate Condtioning Setup dialog"

    # If use_ConditionSetup is 1, below setting are ignored.
    PP_interval_images = 60 #[images]
    PP_drift_wait_time = 3 #[min]
    PP_charge_up_time = 1 #[min]

    #====================================================
    # Display Setting
    #====================================================  
    stop_display_R = 1 # 0:display, 1:stop display

    # Just for "EarlyReturnNextShot".
    # This is for no return for Record Frame exposure for a K2/K3 camera. 0 means no return.
    noReturn = 0
 
    # How often do you want to show images?
    # If you want to see the recorded image for every movie (DisplayOnly=1) or 
    # only for every 10th movie (DisplayOnly=10) or even more rarely:
    DisplayOnly = 1000

    #====================================================
    # LogImage Setting
    #====================================================  
    save_V = 1 # 0:No, 1:Yes
    save_T = 0 # 0:No, 1:Yes
    save_F = 0 # 0:No, 1:Yes
    save_R = 0 # 0:No, 1:Yes
    savelognewfile = 0 # 0:No, 1:Yes

Echo ---> Calling Parameters ...
EndMacro
Macro	21
ScriptName SPADataCollection

#===================================================================
# Main script for the SPA data collection.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# 1. Run "FindVectorRoutine" if you perfom multiple hole.
# 2. Set "Paramters" script.
# 3. Set camera parameters and frame saving folder.
# 4. Take points on the square maps.
# 5. Run "AlignComaAndStig" script.
# 6. Start this script from "Navigator > Acquire at items".
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

workflowType = 1 # 0: Other task, 1: Data collection, 2: Screening

CallFunction SPADataCollection::Core $workflowType 

#######################################################

    Function Core 1 0 workflowType 

        Echo =============== Starting SPADataCollection Macro =============== 

        SuppressReports
        SetLowDoseMode 1

        ReportTickTime
        ticks0 = $repVal1

        CallFunction EMProperties::LoadAdditionalProperties

        If $workflowType == 1
            Call Parameters
        ElseIf $workflowType == 2
            Call Parameters_Screening
        EndIf

        Call Initializer

        CallFunction FlashingMonitor

        CallFunction DarkRefMonitor

        CallFunction UpdateGroupZ

        CallFunction AlignToHole

        CallFunction Controller::FocusControl

        CallFunction Controller::DriftControl

        CallFunction Controller::TiltControl

        CallFunction RealignToHole

        CallFunction ReportStatus

        CallFunction AquireMultiHoles

        CallFunction MeasureThickness

        CallFunction ResetStatus $btx_base $bty_base

        CallFunction Controller::ZLPControll

        CallFunction PhasePlateMonitor

        CallFunction ReportProgress $ticks0

        CallFunction DoSomethingAtEnd

     EndFunction 

#######################################################

    Function FlashingMonitor 0 0

        IsVariableDefined last_flashing
        If $repVal1 == 0
            last_flashing := $initial_ticks
        EndIf
        
        ReportTickTime current_ticks
        flashing_elapsed_ticks = $current_ticks - $last_flashing

        If $flashing_elapsed_ticks >= $FlashInterval
            echo ---> Flashing ...
            LongOperation FF 0 # Flashing
            ReportTickTime
            last_flashing := $repVal1
            flashed := 1
        Else
            flashed := 0
        EndIf

        # For tilted data collection with Cold-FEG
        If $do_tilt == 1
            CallFunction Funcs::CycleTargetTilt
        Else
            TT = 0
        EndIf

    EndFunction

#######################################################

    Function DarkRefMonitor 0 0

        If $update_dark == 1
            IsVariableDefined last_dark
            If $repVal1 == 0
                last_dark := $initial_ticks
            EndIf

            ReportTickTime current_ticks
            darkRef_elapsed_ticks = $current_ticks - $last_dark

            If $darkRef_elapsed_ticks >= $DarkRefInterval
                echo ---> Dark ref updating ...
                LongOperation Da 0 # DarkRef
                ReportTickTime
                last_dark := $repVal1
                dark_updated := 1
            Else
                dark_updated := 0
            EndIf
        Else
            dark_updated := 0
        EndIf

    EndFunction

#######################################################

    Function UpdateGroupZ 0 0

        process @= UpdateGroupZ
        ReportTickTime
        start_ticks = $repVal1

        group_FLAG := 0

        CallFunction Funcs::WaitForRefilling

        IsVariableDefined CURRENTGROUP
        If $repval1 == 0
            CURRENTGROUP := 0
            accum_item_shiftX := 0
            accum_item_shiftY := 0
        EndIf

        ReportGroupStatus
        groupID = $repval2

        If $CURRENTGROUP != $groupID

            # Reset Item coordinate
            Echo ===> Reset Item coordinates
            ShiftItemsByMicrons $accum_item_shiftX $accum_item_shiftY
            accum_item_shiftX := 0
            accum_item_shiftY := 0
            ReportNavItem 
            item_id =  $repVal1
            Echo ===> Move to Item $item_id
            MoveToNavItem $item_id
            CallFunction Funcs::CustomMoveStage 0 0

            # Update Z hight
            CURRENTGROUP := $groupID
            If ( $do_Z_byV == 1 )
                Echo ----> Update Z-height
                Call Z_byV
                ReportStageXYZ
                groupZ := $repVal3
                UpdateGroupZ
                UpdateItemZ
                # Drift control in View
                CallFunction Funcs::WaitForDrift 5 V
            EndIf
            group_FLAG := 1

        EndIf
        
        ReportTickTime
        end_ticks = $repVal1
        CallFunction Funcs::ElapsedTimeMonitor $start_ticks $end_ticks $process

    EndFunction

#######################################################

    Function SkipEdgePoints

       ReportNavItem
       Echo Number of holes :  $navNumHoles
       Echo Nav label : $navLabel

       # TODO
       # SKIP EDGE POINTS

       navNumHoles = 1

    EndFunction 

#######################################################

    Function AlignToHole 0 0

        CallFunction Funcs::AlignToHole $maxholeshift $max_align_iter $align_byIS $use_YL $template_buffer
    
    EndFunction

#######################################################

    Function RealignToHole 0 0

        # Skip in case of lacey grid
        If $grid_type == 0
            Echo ===> Skip hole alignment.
            Return
        EndIf

        If ( ($focus_method == 1) AND ($group_FLAG == 1) ) OR ($realignBeforeRecord == 1)
            If $stop_hole_realign == 1
                Echo ===> Stop hole alignment after Focusing or Drift control
            ElseIf $do_tilt == 0
                Echo ===> Performs hole realign.
                GoToLowDoseArea R
                CallFunction Funcs::AlignToHole $maxholeshift $max_align_iter $align_byIS $use_YL $template_buffer
                GoToLowDoseArea T
                GoToLowDoseArea F
                GoToLowDoseArea R
              
            EndIF
        EndIf

    EndFunction

#######################################################

    Function AquireMultiHoles 0 0

        CallFunction ImageAcquisition::AquireMultiHoles 

    EndFunction

#######################################################

    Function ReportStatus 0 0

        ReportStageXYZ
        old_x := $repVal1
        old_y := $repVal2
        old_z := $repVal3
        Echo ===> X:$old_x Y:$old_y Z:$old_z

        ReportTiltAngle
        Echo ===> Tilt:$repVal1

    EndFunction

#######################################################

    Function ResetStatus 2 0 btx_base bty_base

        # Reset tilt angle
        If $TT != 0
            CallFunction CustomTilt::ResetTiltStage
        EndIf

        # Reset Beam-Tilt
        GoToLowDoseArea R
        SetBeamTilt $btx_base $bty_base
        ReportBeamTilt btx_last bty_last
        Echo ===> Reset Beam-Tilt to ( BTx: $btx_last, BTy: $bty_last )

    EndFunction

#######################################################

    Function MeasureThickness

        If $measure_thickness == 0
            Return
        EndIf

        Echo ===> Measuring the thickness

        SetExposure R 0.5
        SetDoseFracParams R 0 0 0 0 0

        # R
        # ElectronStats A
        # electron_count_slitIn = $repVal5

        GoToLowDoseArea R
        CallFunction Funcs::CustomSetSlitIn 0
        UpdateLowDoseParams R

        R
        ElectronStats A
        electron_count_slitOut = $repVal5

        RestoreCameraSet R
        RestoreLowDoseParams R

        thickness = $electron_count_slitIn / $electron_count_slitOut
        thickness = ROUND $thickness 2

        If $thickness <= 0.7
            message_thickness @= "Too thick"
            ChangeItemColor $current_item 0 # red
        ElseIf 0.7 < $thickness AND  $thickness <= 0.8
            message_thickness @= "Thick"
            ChangeItemColor $current_item 3 # yellow
        ElseIf 0.8 < $thickness AND  $thickness <= 0.9
            message_thickness @= "So so"
            ChangeItemColor $current_item 1 # green
        ElseIf 0.9 < $thickness AND  $thickness <= 0.95
            message_thickness @= "Thin"
            ChangeItemColor $current_item 2 # blue
        Else
            message_thickness @= "Super thin! (or Empty)"
            ChangeItemColor $current_item 2 # blue
        EndIf 

        ChangeItemNote $current_item Thickness : $thickness, $message_thickness

        Echo ========================================================
        Echo ===> Thickness : $thickness (MeanRatio of slit in/out)
        Echo ===> $message_thickness
        Echo ========================================================

        ### Report ### 
        ReportAlpha alpha
        ReportSpotSize spot_size
        ReportPercentC2 brightness
        ReportMag mag
        ReportStageXYZ stage_x stage_y stage_z

        ImageProperties A
        bin = $repVal3
        exposure = $repVal4
        pixsize = $repVal5 * 10

        dose_rate = ( $electron_count_slitIn / ($pixsize * $pixsize) ) / $thickness
        total_dose = $dose_rate * $exposure

        ReportTargetDefocus target_defocus

        RunInShell echo Spot : $spot_size >> $img_info_file
        RunInShell echo Angle : $alpha >> $img_info_file
        RunInShell echo Binning : $bin >> $img_info_file
        RunInShell echo Pixel size (at x$mag) : $pixsize [A/px] >> $img_info_file
        RunInShell echo Exposure time : $exposure [sec] >> $img_info_file
        RunInShell echo Target Defocus : $target_defocus [um] >> $img_info_file
        RunInShell echo Acquisition point (X, Y, Z) : $stage_x $stage_y $stage_z [um] >> $img_info_file
        RunInShell echo ---------------------------------------------------------------- >> $img_info_file
        RunInShell echo Dose rate on detector : $electron_count_slitIn [e/px/s] >> $img_info_file
        RunInShell echo Dose rate on specimen : $dose_rate [e/A^2/s] >> $img_info_file
        RunInShell echo Total dose on specimen : $total_dose [e/A^2] >> $img_info_file

        RunInShell echo ======================================================== >> $img_info_file
        RunInShell echo Thickness : $thickness (MeanRatio of slit in/out) >> $img_info_file
        RunInShell echo $message_thickness >> $img_info_file
        RunInShell echo ======================================================== >> $img_info_file

    EndFunction

#######################################################

    Function PhasePlateMonitor

        If $use_PhasePlate == 1

            IsVariableDefined PP_moved
            If $repVal1 == 0
                PP_moved := 0
                last_PP_image_num := $acquired_image_num
            EndIf

            If $use_ConditionSetup == 1
                Echo ===> Setting Phase Plate to a new position
                ConditionPhasePlate 1
                PP_moved := $PP_moved + 1
            ElseIf ($acquired_image_num - $last_PP_image_num) > $PP_interval_images
                Echo ===> Setting Phase Plate to a new position
                PhasePlateToNextPos
                Echo ---> Waiting for Phase Plate drift settling. $PP_drift_wait_time [min]
                Delay $PP_drift_wait_time min
                SetBeamBlank 0
                Echo ---> Waiting for Phase Plate charge up. $PP_charge_up_time [min]
                Delay $PP_charge_up_time min
                SetBeamBlank 1
                PP_moved := $PP_moved + 1
                last_PP_image_num := $acquired_image_num
            EndIf

            Echo ===> Phase Plate moved $PP_moved times

        Else
            PP_moved := 0
        EndIf

    EndFunction

#######################################################

    Function ReportProgress 1 0 ticks0

        ReportNumNavAcquire num_remain_item

        ReportTickTime current_ticks
        elapsed_ticks = $current_ticks - $ticks0
        total_elapsed_ticks = $current_ticks - $initial_ticks

        # convert to [min]
        elapsed_ticks = $elapsed_ticks / 60
        total_elapsed_ticks = $total_elapsed_ticks / 60

        # report progress
        Echo ===> Item $current_item took $elapsed_ticks min.
        Echo ===> Flashing:$flashed Refilling:$refilled ZLP:$ZLP_aligned DarkRef:$dark_updated
        ReportBeamTilt
        Echo ===> BeamTilt Monitor $repVal1 $repVal2       

        If $total_elapsed_ticks <= 60
            Echo --> Elapsed time $total_elapsed_ticks min
        Else
            total_elapsed_ticks = $total_elapsed_ticks / 60
            Echo --> Elapsed time $total_elapsed_ticks hr
        EndIf

    EndFunction

#######################################################

    Function ChangeFocusForTilt 1 0 sp_y

        If $TT != 0

            additional_defocus = -1 * $sp_y * tan ( $TT )

            setting_defocus = $origin_defocus + $additional_defocus

            #If $apply_defocus_offset == 1
            #    SetDefocus $defocus_offset
            #EndIf

            SetDefocus $setting_defocus

            Echo ===> Defocus : $setting_defocus [um]

        EndIf

    EndFunction


#######################################################

    Function DoSomethingAtEnd

        ReportNextNavAcqItem
        If $navIndex != -1
            Return
        EndIf

        If $workflowType == 2
            Return
        EndIf

        Echo ===> Data collection finished.
        Echo ===> Close Gun valve.
        SetColumnOrGunValve 0

        Echo ===> Lower screen.
        ScreenDown

        Echo ===> Retract all camera
        RetractCamera

        Echo ===> Turn off emission.
        SetFEGEmissionState 0

        ClearPersistentVars 

    EndFunction

#######################################################
EndMacro
Macro	23
ScriptName CalibrationBeamVSImage_onScreen

#===================================================================
# This script is for calibration beam shift vs image shift.
# --------------------------------------------------------------------------------------------------------------------
# <How to run>
# Enter four values getting from this script in calibration file (C:\\ProgramData\SrialEM\SerialEMcalibrations.txt)
# At first, screen down and check beam centering on screen
# --------------------------------------------------------------------------------------------------------------------
# Made for CryoARM300 in Osaka.U by F.Makino
#===================================================================

shiftBeam = 5 #[um]
waittime  = 10


ScreenDown
GoToLowDoseArea R
SetImageShift 0 0

echo Report Beam shift and Image shift on Image shift (0,0)
ReportImageShift
i0_shiftx = $RepVal1
i0_shifty = $RepVal2

ReportBeamShift
b0_shiftx = $RepVal1
b0_shifty = $RepVal2

ImageShiftByMicrons 0 0 # 1 1

echo Beam centering by beam shift knob (Beam Align 1) on screen within $waittime [sec]
count = $waittime
loop $waittime
   echo remaining time $count [sec]
   delay 1
   count = $count - 1
EndLoop
#T

# ========= 1st ============
echo 1st Image shift ($shiftBeam,0) ...
ImageShiftByMicrons $shiftBeam 0 1 0
#T

ReportImageShift
i1_shiftx = $RepVal1
i1_shifty = $RepVal2

echo
echo Beam centering by beam shift knob (Beam Align 1) on screen within $waittime [sec]
count = $waittime
loop $waittime
   echo remaining time $count [sec]
   delay 1
   count = $count - 1
EndLoop


ReportBeamShift
b1_shiftx = $RepVal1
b1_shifty = $RepVal2

xb1 = $b1_shiftx - $b0_shiftx
yb1 = $b1_shifty - $b0_shifty
xi1 = $i1_shiftx
yi1 = $i1_shifty

#reset beam
SetImageShift 0 0
SetBeamShift $b0_shiftx $b0_shifty
delay 1
# =========================

# ========= 2nd ============
echo 2nd Image shift (0, $shiftBeam) ...
ImageShiftByMicrons 0 $shiftBeam 1 0
#T

ReportImageShift
i2_shiftx = $RepVal1
i2_shifty = $RepVal2

echo
echo Beam centering by beam shift knob (Beam Align 1) on screen within $waittime [sec]
count = $waittime
loop $waittime
   echo remaining time $count [sec]
   delay 1
   count = $count - 1
EndLoop

ReportBeamShift
b2_shiftx = $RepVal1
b2_shifty = $RepVal2

xb2 = $b2_shiftx - $b0_shiftx
yb2 = $b2_shifty - $b0_shifty
xi2 = $i2_shiftx
yi2 = $i2_shifty

#Reset beam
SetImageShift 0 0
SetBeamShift $b0_shiftx $b0_shifty
delay 1
# =========================
a = ( $xb1 * $yi2 -  $xb2 * $yi1 ) / ( $xi1 * $yi2 - $xi2 * $yi1 )
b = ( $xb1 * $xi2 -  $xb2 * $xi1 ) / ( $xi2 * $yi1 - $xi1 * $yi2 )
c = ( $yb1 * $yi2 -  $yb2 * $yi1 ) / ( $xi1 * $yi2 - $xi2 * $yi1 )
d = ( $yb1 * $xi2 -  $yb2 * $xi1 ) / ( $xi2 * $yi1 - $xi1 * $yi2 )

ReportMagIndex
magIn = $RepVal1
ReportMag
mag = $RepVal1
ReportAlpha
alpha = $RepVal1 - 1

echo Result of calibration is as follows... Rewrite it on "BeamShiftCalibration" line in C:\\ProgramData\SrialEM\SerialEMcalibrations.txt
#echo $a $b $c $d
echo BeamShiftCalibration $magIn $a $b $c $d $alpha 1  $mag
EndMacro
Macro	24
ScriptName ZLPAlignByFL

#===================================================================
# This script refine ZLP by FL.
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    # ============================
    # Parameters
    # ============================

    search_range = 40 # [step]. If set 40, range from -20 to +20.
    search_step = 1 # [step]

    ZLP_thld_ratio = 0.7
    area = R # Area for ZLP alignment

    # ============================
    # Main
    # ============================

    CallFunction ZLPAlignByFL::Core $search_range $search_step $ZLP_thld_ratio $area

###################################################

    Function Core 3 1 search_range search_step ZLP_thld_ratio area

        CallFunction EMProperties::LoadAdditionalProperties

        If $hasOmegaFilter  == 0
            Echo ===> This machine does not have Omega filter.
            Echo ===> Do not run ZLPAlignment.
            Return
        EndIf

        RunInShell $FLserver
        delay 12

        SuppressReports
        GoToLowDoseArea $area

        # If slit is removed, Skip.
        CallFunction Funcs::CustomReportEnergyFilter
        If $repVal3 <= 0
            Echo ===> Energy Filter Slit is removed. Or does not exist. 
            Echo ===> Skip ZLP refine.
            Return
        Endif

        # Get slit width
        #ReportEnergyFilter
        #slit_width = $repVal1

        # Set Record mode params for RefineZLP
        SetExposure $area 0.5
        SetDoseFracParams $area 0 0 0 0 0

        # Start RefineZLP
        Echo # ======================================
        Echo ===> Start RefineZLP
        Echo Search range : $search_range [step]
        Echo Refinement FL step : $search_step [step]

        FL_min = NEARINT ( -1 * $search_range / 2 - $search_step )

        ZLP_thld = 0
        NewArray arr_count -1 $search_range 
        NewArray arr_FL_shift -1 $search_range 

        # Set FL to lower limit
        RunInShell $shiftFL $FL_min
      
        # Get array of electron count
        Echo ===> Searching ZLP Center
        ZLPmin = 0  
        Loop $search_range idx
            RunInShell $shiftFL $search_step

            $area
            ElectronStats A
            arr_count[$idx] = $repVal5
            arr_FL_shift[$idx] = $FL_min + $search_step * $idx
            Echo Search Index $idx : FL_shift = $arr_FL_shift[$idx], count = $arr_count[$idx]

            If ($arr_count[$idx] > $ZLP_thld) AND ($arr_count[$idx] > 1)
                ZLP_thld = $arr_count[$idx] * $ZLP_thld_ratio
                ZLPmin = $ZLP_thld * 0.1
            EndIf
            
            If $arr_count[$idx] < $ZLPmin
                Echo ===> ZLP end.
                Break
            EndIf
        EndLoop

        # Get ZLP width (to create following array of ZLP positions)
        ZLP_size = 0
        Loop $#arr_count idx
            If $arr_count[$idx] > $ZLP_thld
                ZLP_size = $ZLP_size + 1
            EndIf
        EndLoop
        Echo ===> ZLP size : $ZLP_size

        # Get ZLP position
        NewArray ZLP_positions -1 $ZLP_size
        idx2 = 0
        Loop $#arr_count idx1
            If $arr_count[$idx1] > $ZLP_thld
                idx2 = $idx2 + 1
                ZLP_positions[$idx2] = $idx1
                #Echo ZLP Index : $ZLP_positions[$idx2]
            EndIf
        EndLoop

        # Find ZLP center
        center_idx = NEARINT ( ($ZLP_size + 1) / 2 )
        ZLP_center = $ZLP_positions[$center_idx]

        isEvenSize = ( MODULO $ZLP_size 2 ) + 1            
        If $isEvenSize == 1
            If ($arr_count[$ZLP_center-1] > $arr_count[$ZLP_center])
                ZLP_center = $ZLP_center - 1
            EndIf
        EndIf

        Echo ZLP Center : Index = $ZLP_center, count = $arr_count[$ZLP_center]

        # Set FL to ZLP center
        Echo ===> Apply $arr_FL_shift[$ZLP_center] FL shift
        #FL_shift_fromEnd = ($ZLP_center - $search_range) * $search_step
        FL_shift_fromEnd = ($ZLP_center - $ZLP_positions[$idx2] - 2) * $search_step
        RunInShell $shiftFL $FL_shift_fromEnd
        echo $shiftFL $FL_shift_fromEnd

        # Reset Record mode params
        RestoreCameraSet $area

        Echo ===> Finish RefineZLP
        Echo # ======================================

        # Stop server
        RunInShell $shiftFL x

    EndFunction

###################################################
EndMacro
Macro	27
ScriptName SetFocusTrialIllumination

    # ==============================
    # Parameters
    # ==============================
    frac = 0.9 # Value must be 0 ~ 1. If the value is close to 0, beam is almost crossover. If the value is close to 1, beam is almost same with Record.
    linear_or_counting = 1 # 0: linear, 1: counting on Trial
    do_beamCentering = 1 # 0:No, 1:Yes, Do beam centering at last on Trial?

    # ==============================
    # Main
    # ==============================
    SuppressReports 

    # Get parallel and crossover C2 values on Record
    SetLowDoseMode 1
    GoToLowDoseArea R

    YesNoBox Have you already set up Record mode?
    If $repVal1 == 0
        OKBox Please set up Record mode first.
        Exit
    EndIf
    
    ReportMag
    recordMag = $repVal1
    
    reportSpotSize
    recordSpot = $repVal1

    ReportAlpha
    recordAlpha = $repVal1

    ReportPercentC2
    recordC2 = $repVal1

    ReportCrossoverPercentC2
    crossoverC2 = $repVal1

    CallFunction CustomReportEnergyFilter
    recordFilterInOut = $repVal3

    # Calculate the target trial C2 value
    If ( $frac < 0 ) OR ( 1 < $frac )
        frac = 0.9
    EndIf
    trialC2 = $crossoverC2 + ( $recordC2 - $crossoverC2 ) * $frac
    Echo $crossoverC2 $recordC2 $trialC2

    # Set Focus and Trial illumination
    #SetLDContinuousUpdate 1
    GoToLowDoseArea F
    SetSpotSize $recordSpot
    SetAlpha $recordAlpha
    SetPercentC2 $recordC2
    CallFunction Funcs::CustomSetSlitIn $recordFilterInOut
    Delay 2 sec
    UpdateLowDoseParams F 1

    GoToLowDoseArea T
    #SetLDContinuousUpdate 1
    SetSpotSize $recordSpot
    SetAlpha $recordAlpha
    SetPercentC2 $trialC2
    CallFunction Funcs::CustomSetSlitIn $recordFilterInOut
    Delay 2 sec
    UpdateLowDoseParams T 1

    # BeamCentering on Trial
    If $do_beamCentering == 1
       T
       CenterBeamFromImage A
       T
    EndIf

    OKBox Finished. Please find a good place to do Z_byV.

    ScreenDown
EndMacro
Macro	28
ScriptName Check_ActiveBTComp

#===================================================================
# To check the calibration of "Coma vs ImageShift".
# LowDoseMode must be set up before running this script.
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion Repository.
# Modified by TF and FM.
#===================================================================

IS_distance = 3 #[um]
exp_time = 1
BTtoIS = 1
ISDelay = 0 #[s]

# ==========================================

SuppressReports 
SetExposure R $exp_time 
SetBinning R 2
SetDoseFracParams R 0 0 0 0 0

Echo ===> Set IS to 0
SetImageShift 0 0
FixComaByCTF 1 1

Echo ===> Applying $IS_distance mircon IS_X
ImageShiftByMicrons $IS_distance 0 $ISDelay $BTtoIS
FixComaByCTF 1 1
SetImageShift 0 0 $ISDelay $BTtoIS

Echo ===> Applying $IS_distance mircon IS_Y
ImageShiftByMicrons 0 $IS_distance $ISDelay $BTtoIS
FixComaByCTF 1 1
SetImageShift 0 0 $ISDelay $BTtoIS

RestoreCameraSet R
EndMacro
Macro	29
ScriptName Initializer

#===================================================================
# This script is part of the "SPADataCollection". 
# This initializes some part of parameters.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

    #====================================================
    # Grid type
    #====================================================
    Try
        ReadTextFile grid_type $NAVIGATOR_PATHGrid_type.txt
        Echo ===> grid_type is $grid_type
    Catch
        grid_type = 1
        Echo ===> Grid_type.txt does not exist. Use grid_type of 1 (Quantifoil).
    EndTry

    If $grid_type == 0
        Echo ===> Use lacey grid workflow.
    ElseIf $grid_type == 1
        Echo ===> Use Quantifoil/UltrAuFoil workflow.
    Else
        Echo ===> Grid type $grid_type has not yet determined.
    EndIf

    #====================================================
    # PolePiece type
    #====================================================
    If $narrowGapPP == 1
        do_tilt = 0
    EndIf

    #====================================================
    # Initial setting
    #====================================================
    # workflowType 0: Data collection, 1: Screening
    # For Parameters
    If $workflowType == 1
        IsVariableDefined Initializer
        
        log_dir = $NAVIGATOR_PATHLogImage_DataCollection

        If $repVal1 == 0
            CallFunction Initializer::SetGlobalData
            # Set Initializer
            Initializer := 1
        EndIf      

        settingFileDir @= LastSettings_DataCollection
        RunInShell mkdir $NAVIGATOR_PATH\$settingFileDir

    # For Parameters_Screening
    ElseIf $workflowType == 2
        IsVariableDefined Initializer_Screening
        
        log_dir = $NAVIGATOR_PATHLogImage_Screening

        If $repVal1 == 0
            CallFunction Initializer::SetGlobalData
            # Set Initializer
            Initializer_Screening := 1
        EndIf

        settingFileDir @= LastSettings_Screening
        RunInShell mkdir $NAVIGATOR_PATH\$settingFileDir

    # For something other...
    Else
        Echo ===> Please set correct workflowType value.
    EndIf

    # Open Gun Valve
    ReportColumnOrGunValve 
    If $repVal1 == 0
       SetColumnOrGunValve 1
    EndIf

    #SaveLog

    #====================================================
    # Display counting
    #====================================================
    # Mainly used for maintainance. Display every few hours only,
    If $workflowType == 1
        If $Initializer != 0 

            Initializer := $Initializer - 1
            DISPLAYCOUNTER := $DISPLAYCOUNTER - 1
            Echo Displaying in $DISPLAYCOUNTER item images.

            If $DISPLAYCOUNTER < 1
                # show images & reset DISPLAYCONTER
                DisplayReturn := $noReturn
                DISPLAYCOUNTER := $DisplayOnly
            Else
                # NOT show images
                DisplayReturn := 0
            EndIf

        Else
            # Reset Initializer
            Initializer := 1

        EndIf
    ElseIf $workflowType == 2
        If $Initializer_Screening != 0

            Initializer_Screening := $Initializer_Screening - 1
            DISPLAYCOUNTER := $DISPLAYCOUNTER - 1
            Echo Displaying in $DISPLAYCOUNTER item images.

            If $DISPLAYCOUNTER < 1
                # show images & reset DISPLAYCONTER
                DisplayReturn := $noReturn
                DISPLAYCOUNTER := $DisplayOnly
            Else
                # NOT show images
                DisplayReturn := 0
            EndIf

        Else
            # Reset Initializer_Screening
            Initializer_Screening := 1

        EndIf
    Else
        Echo ===> Please set correct workflowType value.
    EndIf

    #====================================================
    # Initialize Flashing, LN2 Refill, ZLP Centering, Dark ref update settings
    #====================================================
    IsVariableDefined flashed
    If $repVal1 == 0
        flashed := 0
    EndIf

    IsVariableDefined refilled 
    If $repVal1 == 0
        refilled := 0
    EndIf

    IsVariableDefined ZLP_aligned 
    If $repVal1 == 0
        ZLP_aligned := 0
    EndIf

    IsVariableDefined dark_updated 
    If $repVal1 == 0
        dark_updated := 0
    EndIf

    If $refilled == 1
        # Change TT by refilling
        If $do_tilt == 1
            CallFunction Funcs::CycleTargetTilt
        Else
            TT = 0
        EndIf
    EndIf

    refilled := 0

    #====================================================
    # Z adjust
    #====================================================
    If ($focus_method == 1) OR ($do_tilt == 1)
        GoToLowDoseArea R
        SetEucentricFocus
    EndIf

    # ---- For CorrectWrongZ Function ----
    IsVariableDefined groupZ
    If $repVal1 == 0
        ReportStageXYZ 
        groupZ := $repVal3
    EndIf
    # ---------------------------------------------

    #====================================================
    # Omega filter
    #====================================================
    If $hasOmegaFilter == 0
        do_refineZLP = 0
    EndIf

    #====================================================
    # Other paremeter initialize
    #====================================================
    # Initial BeamTilt value
    GoToLowDoseArea R
    ReportBeamTilt btx_base bty_base
    Echo ===> Initial Beam-Tilt value ( BTx: $btx_base, BTy: $bty_base )

    # Focus
    TD_low     = -1 * ABS ($TD_low)
    TD_high    = -1 * ABS ($TD_high)
    TD_step    = ABS ($TD_step)

    If $TD_low <= $TD_high
        TD_high = $TD_low - 0.5
    EndIf

    focused = 0

    # Acquired image initialize
    IsVariableDefined acquired_image_num
    If $repVal1 == 0
        acquired_image_num := 0
    EndIf

    # Set layer for lacey grid.
    If $grid_type == 0
        ReadTextFile lacey_layer $NAVIGATOR_PATHLacey_layer.txt
        LAYER = $lacey_layer 
        Echo ===> Set lacey grid parameter (Layer: $lacey_layer)
    EndIf
    
    If $workflowType == 2
       LAYER = 0
    EndIf

    # Record. Multi-hole setting.
    If ($LAYER != 0) AND ($use_multiR < 2)
        ReadTextFile vector $NAVIGATOR_PATHVectors_RecordMode.txt
        IS_RAD1_h   = $vector[1]
        IniAng_h    = $vector[2]
        IS_RAD1_v   = $vector[3]
        IniAng_v    = $vector[4]
    EndIf

    If $use_multiR != 0
        BTtoIS = 0
    EndIf

    # Measure thickness
    If $PATTERN != 1
        measure_thickness = 0
    EndIf

    # Tilt
    If $do_tilt == 1
        If $#TT_list != $#TT_freq
            Echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            Echo Number of elements of target tilt list and frequency list has mismatch!
            Echo Tilt will not be performed.
            Echo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            do_tilt = 0
        # Reset focus setting for tilted data collection
        Else
            focus_method = 1 # Z
            
        EndIf

    EndIf

    # StageProperty
    If $use_apprV == 1
        CallFunction Funcs::CustomMoveStage 0 0
    EndIf

    acq_count := $acq_count + 1

    # Check slit is in
    If $measure_thickness == 1
        GoToLowDoseArea R
        CallFunction Funcs::CustomReportEnergyFilter
        If $repVal3 == 0
            Echo ===> Energy filter slit is out at Record mode.
            Echo ===> Insert  energy filter slit anyway.
            CallFunction Funcs::CustomSetSlitIn 1
        ElseIf $repVal3 == -1
            Echo ===> Will not measure ice thickness.
            measure_thickness = 0
        EndIf
    EndIf

    # If record camera is not K2/K3
    If $recordCam > 2 
       stop_display_R = 0
       noReturn = -1
    EndIf

    #====================================================
    # Save SerialEMsettings.txt
    #====================================================
    ReportSettingsFile SEMsetting SEMscript
    RunInShell copy $SEMsetting $NAVIGATOR_PATH\$settingFileDir
    RunInShell copy $SEMscript $NAVIGATOR_PATH\$settingFileDir

    #====================================================
    # Current info
    #====================================================
    ReportNavItem
    current_item := $repVal1
    item_label = $navLabel
    
    NavIndexItemDrawnOn $current_item
    map_item = $repVal1
    ReportOtherItem $map_item
    map_label = $navLabel

    ReportStageXYZ
    curr_x = $repVal1
    curr_y = $repVal2
    curr_z = $repVal3
    
    
####################################################################

    Function SetGlobalData 0 0

        # Set initial time
        ReportTickTime
        initial_ticks := $RepVal1

        # Set focus counter
        FOCUSCOUNTER := 0
        focus_problem_counter := 0

        # Set center beam counter
        centerBeamCounter := 0

        If $savelognewfile == 1
           # Set log file
           SaveLogOpenNew LOGFILE.log
           SaveLog 
        Endif 

        # Initialize DISPLAYCOUNTER (see below)
        DISPLAYCOUNTER := $DisplayOnly

        # Initialing stage
        LASTX := 10000
        LASTY := 10000
        LASTZ := 10000

        # Focus log initialize
        focused = 0

        # Set standard focus
        ReportLowDose
        If $repVal2 == 0 # V
            GoToLowDoseArea T
            GoToLowDoseArea F
        ElseIf $repVal2 == 2 # T
            GoToLowDoseArea F
        EndIf
        GoToLowDoseArea R
        SetEucentricFocus
        ResetDefocus 

        # Reset tilt
        If $do_tilt == 1
            TiltTo (-1 * $backlash_tilt)
            TiltTo $backlash_tilt
            TiltTo 0
        Endif 

        acq_count := -1

        # Read hole image
        If $grid_type != 0
            CallFunction Funcs::ReadHoleImage
        EndIf

        # Set log image saving folder
        RunInShell mkdir $log_dir
        log_dirV :@= $log_dir\View
        log_dirT :@= $log_dir\Trial
        log_dirF :@= $log_dir\Focus
        log_dirR :@= $log_dir\Record
        RunInShell mkdir $log_dirV
        RunInShell mkdir $log_dirT
        RunInShell mkdir $log_dirF
        RunInShell mkdir $log_dirR

    EndFunction
EndMacro
Macro	30
ScriptName Funcs

#===================================================================
# functions which can be called from a macro or a function.
# --------------------------------------------------------------------------------------------------------------------
# Imported from Nexperion repository.
# Modified by TF and FM.
#===================================================================


#######################################################

    Function CycleTargetDefocus 0 0

        Echo ===> Running CycleTargetDefocus ...
        Echo >>>> defined Range and Step (um)  => [ $TD_low, $TD_high ], [ $TD_step ].

        delta = -1 * $TD_step

        SuppressReports
        ReportTargetDefocus 

        If ( $repVal1 > $TD_low ) OR ( $repVal1 < $TD_high )
            SetTargetDefocus $TD_low
        Else
            IncTargetDefocus $delta
        Endif

        ReportTargetDefocus TD
        TD = ROUND $TD 2
        Echo TargetDefocus = $TD um

    EndFunction 

#######################################################

    Function CycleTargetTilt 0 0

        len_TT_list = $#TT_list

        # Set initial TT_freq_tmp 
        IsVariableDefined TT_freq_tmp
        If $repVal1 == 0
            TT_freq_tmp := $TT_freq
        EndIf

        # If flashing was performed, then update Target Tilt
        If ($changeTT_byFlashing == 1) AND ($flashed == 1)
            Loop $len_TT_list idx
                If $TT_freq_tmp[$idx] != 0
                    TT_freq_tmp[$idx] := $TT_freq_tmp[$idx] - 1
                    Break
                EndIf
            EndLoop
        EndIf

        # Before setting Target Tilt, check whether all elements of TT_freq_tmp are zero.
        keep_TT_freq = 0
        Loop $len_TT_list idx
            keep_TT_freq = $keep_TT_freq + $TT_freq_tmp[$idx]
        EndLoop
        # If zero, then reset TT_freq_tmp.
        If $keep_TT_freq == 0
            TT_freq_tmp := $TT_freq
            Echo ===> Target tilt is reset.
        EndIf

        # Set Target Tilt
        Loop $len_TT_list idx
            If $TT_freq_tmp[$idx] != 0
                TT = $TT_list[$idx]
                # Update Target Tilt for flashing-independet setting
                If $changeTT_byFlashing == 0
                    TT_freq_tmp[$idx] := $TT_freq_tmp[$idx] - 1
                EndIf
                Break
            Else
                Continue
            EndIf
        EndLoop

        Echo ===> Target tilt angle : $TT [degree]
        
    EndFunction

#######################################################

    Function WaitForRefilling 0 0

        IsVariableDefined workflowType
        If $repVal1 == 0
            workflowType = 0
        EndIf
        If $workflowType == 0
            Return
        Endif 

        If $hasLN2Tank == 0
            Return
        EndIf

        AreDewarsFilling  # report 1 for stage tank. report 2 for transfer tank.

        If $repVal1 >= 1

            LongOperation RS 0 RT 0

            # Flashing at a time
            If $flash_when_refill == 1
                LongOperation FF 0
                ReportTickTime
                last_flashing := $repVal1
                flashed := 1
            EndIf

            # Dark ref at a time
            If ($darkRef_when_refill == 1) AND ($update_dark == 1)
                LongOperation Da 0
                ReportTickTime
                last_dark := $repVal1
                dark_updated := 1
            EndIf

            refilled := 1

            Loop 60

                Delay 30 sec
                AreDewarsFilling 

                If $repVal1 == 0
                    Break
                EndIf

                #Echo Still refilling

            EndLoop

            Echo ===> Waiting for the additional settling time of $delay_after_refill [min]
            Delay $delay_after_refill min
            Echo ===> LN2 refill completed.

        EndIf

    EndFunction

#######################################################

    Function ElapsedTimeMonitor 2 1 start_ticks end_ticks process

        ticks = $end_ticks - $start_ticks
        IsVariableDefined current_item

        If $repVal1 == 0
           Echo ===> $process took $ticks
        Else
           Echo ===> $process for $current_item took $ticks
        EndIf 

    EndFunction

#######################################################

    Function WaitForDrift 1 1 crit shot

        # Paremeters
        interval = 10
        times = 60
        period = $interval + 1

        # Skip if drift is already lower than the criteria
        ReportFocusDrift
        focus_drift_x = $repVal1 * 10
        focus_drift_y = $repVal2 * 10 # * -1 ??
        focus_drift = sqrt ( $focus_drift_x * $focus_drift_x + $focus_drift_y * $focus_drift_y )
        Echo -------------------------------
        Echo Focus drift rate: $focus_drift [A/s]
        Echo Rate X: $focus_drift_x [A/s], Rate Y: $focus_drift_y [A/s]
        Echo -------------------------------
        If ($focus_drift <= $crit) AND ($use_focus_drift == 1)
            Echo ===> Focus drift is lower than $crit
            Echo ===> Drift Control would be skipped.
        # If not, do drift control
        Else
            Echo ===> Running WaitForDrift $crit  [A/sec] ...

            $shot
            Delay $interval

            Loop $times idx

                CallFunction WaitForRefilling

                $shot
                AlignTo B
                ReportAlignShift
                ClearAlignment
                dx = $repVal5
                dy = $repVal6 * -1
                dist = sqrt ( $dx * $dx + $dy * $dy )

                If $dist >= 50

                    skip_message @= "Skipped. Failure of cross-correlation while drift measurement"
                    CallFunction Funcs::AnnotateSkipItem $skip_message 
                    SkipAcquiringNavItem
                    Exit

                EndIf

                rate = $dist / $period * 10	
                Echo Rate = $rate A/sec
                Echo driftX:$dx [nm], driftY:$dy [nm]
                Echo ----------------

                If $rate < $crit

                    echo Drift is low enough after shot $idx
                    break

                ElseIf  $idx < $times

                    If $resist_drift == 1
                        CallFunction ResistDrift $dx $dy $rate $crit
                        $shot
                    EndIf

                    Delay $interval

                Else

                    skip_message @= "Skipped because of huge drift."
                    CallFunction Funcs::AnnotateSkipItem $skip_message 
                    SkipAcquiringNavItem
                    Exit

                EndIf

            EndLoop

        EndIf

    EndFunction

#######################################################

    Function ResistDrift 4 0 dx dy rate crit
        
        resist_drift_crit = $crit * 1.0

        If $rate >= $resist_drift_crit
            
            anti_x = -1 * $dx    # -5 * $dx
            anti_y = -1 * $dy    # -5 * $dy
            anti_x_m = $anti_x / 1000 # [um]
            anti_y_m = $anti_y / 1000 # [um]

            Echo ---> Resist a drift.
            Echo ---> Move X:$anti_x [nm]  Y:$anti_y [nm]
            Echo ----------------

            Loop 1
                MoveStage $anti_x_m $anti_y_m
            EndLoop

        Else

            Echo ---> Drift is low enough to stop resisting.

        EndIf
        
    EndFunction

######################################################

    Function CustomMoveStage 2 0 x y

        If $use_apprV == 1
            MoveStage ($x + $apprV_X1) ($y + $apprV_Y1)
            MoveStage ($apprV_X2 - $apprV_X1) ($apprV_Y2 - $apprV_Y1)
            MoveStage (-1 * $apprV_X2) (-1 * $apprV_Y2)
        Else
            MoveStage $x $y
        EndIf

    EndFunction

#######################################################

    Function CustomMoveStageTo 2 0 x y

        If $use_apprV == 1
            MoveStageTo ($x + $apprV_X1) ($y + $apprV_Y1)
            MoveStageTo ($x + $apprV_X2) ($y + $apprV_Y2)
        EndIf

        MoveStageTo $x $y

    EndFunction

#######################################################

    Function GoToNextNavItem 0 0

        If $use_apprV == 1

            ReportNextNavAcqItem

            If $repVal1 != -1
                next_x = $repVal2
                next_y = $repVal3
                next_z = $repVal4
                MoveStageTo ($next_x + $apprV_X1) ($next_x + $apprV_Y1) $next_z
                MoveStageTo ($next_x + $apprV_X2) ($next_x + $apprV_Y2) $next_z
            EndIf

        EndIf

    EndFunction

#######################################################

    Function SetFlipXY 0 0

       CallFunction EMProperties::LoadAdditionalProperties

        flipX := -1
        flipY := -1
        If $hasOmegaFilter == 1
            flipX := 1
            flipY := -1
        EndIf

    EndFunction

#######################################################

Function AlignToHole 4 1 maxholeshift max_align_iter align_byIS use_Yoneo template_buffer

    CallFunction EMProperties::LoadAdditionalProperties

    GoToLowDoseArea V

    # Skip in case of lacey grid
    If $grid_type == 0
        Echo ===> This is a lacey grid. Skip hole alignment.
        Return
    EndIf

    IsVariableDefined workflowType
    If $repVal1 == 0
        workflowType = 0
    EndIf

    If $workflowType == 0
        do_tilt = 0 
        TT = 0
        save_V = 0
     Endif 

    process @= AlignToHole
    ReportTickTime
    start_ticks = $repVal1

    # Initial settings
    maxholeshift_tmp = $maxholeshift
    align_byIS_tmp = $align_byIS

    CallFunction Funcs::SetFlipXY

    If ( $do_tilt == 1 ) AND ( $TT != 0 )
        maxholeshift = 400
        align_byIS = 1
    EndIf

    ReportImageShift IS_X0 IS_Y0
    ReportSpecimenShift sp_x0 sp_y0
    align_err_count = 0

    LowLimitCount = 0.1 # 10 for k3
    diff_x = 0
    diff_y = 0

    ResetImageShift

    # ======== Start Hole Aliginment ========
    CallFunction Funcs::WaitForRefilling
    Echo ===> Running AlignToHole ...

    # Take a first View
    V
    If $save_V == 1
        SaveToOtherFile A JPG NONE $log_dirV\View_beforeAlign_Item$item_label_Square$map_label_$acq_count.jpg
    EndIf

    # Hole align iterration
    Loop $max_align_iter iter
        CallFunction Funcs::WaitForRefilling

        ReportMeanCounts
        MeanCountsF = $reportedValue1
        if ( $MeanCountsF < $LowLimitCount )
            echo Counts too low
            Break 
        EndIf

        CallFunction DetectHoleAndMove $use_Yoneo $iter
        diff_x = $repVal1
        diff_y = $repVal2
        holeshift = $repVal3
        lastShiftX = $repVal4
        lastShiftY = $repVal5

        Echo Hole align iter $iter
        Echo Shift ---> X:$dx [nm] Y:$dy [nm]
        Echo -------------------

        # Success
        If $holeshift < $maxholeshift
            Echo ===> Hole align finished.
            Echo ===> $diff_x $diff_y

            If $workflowType == 1
                # Realign items
                ShiftItemsByMicrons $diff_x $diff_y

                # Accumulated item shift used for reset when group is changed.
                accum_item_shiftX := $accum_item_shiftX - $diff_x
                accum_item_shiftY := $accum_item_shiftY - $diff_y
                diff_x = 0
                diff_y = 0
            EndIf

            If $align_byIS == 0
                SetImageShift 0 0 # IS is anyway 8000 8000 for stage shift
            EndIf

            If $save_V == 1
                SaveToOtherFile A JPG NONE $log_dirV\View_afterAlign_Item$item_label_Square$map_label_$acq_count.jpg
            EndIf

            maxholeshift = $maxholeshift_tmp
            align_byIS = $align_byIS_tmp

            Break
        EndIf

    EndLoop 

    ReportTickTime
    end_ticks = $repVal1
    CallFunction Funcs::ElapsedTimeMonitor $start_ticks $end_ticks $process

EndFunction

#######################################################

Function DetectHoleAndMove 2 0 use_Yoneo iter

    If $use_Yoneo == 1
        Echo ===> Hole detection by YoneoLocker.

        If $iter == 1
            ImageProperties
            xdim1 = $reportedValue1
            ydim1 = $reportedValue2
            binning1 = $reportedValue3
            pixsize1 = $reportedValue5
        Else
            V
        EndIf

        SaveToOtherFile A JPG JPG $progdir\View_$iter.jpg
        RunInShell echo View_$iter.jpg $binning1 > $progdir\WatchHole\$watchinfile
        Delay 0.5s
        DoesFileExist $progdir\View_$iter.jpg

        If $reportedValue1 == 0
            echo Cannot make $progdir\View_$iter.jpg
            echo Try again
            diff_x = 0
            diff_y = 0
            holeshift = 999999
            lastShiftX = 0
            lastShiftY = 0
            return $diff_x $diff_y $holeshift $lastShiftX $lastShiftY 
        EndIf

        GxGyProb = {0., 0., 0.}

        Loop 10
            reportedValue1 = 0
            OpenTextFile 1 T 0 $progdir\View_$iter.log
            Delay 0.1s
            if $reportedValue1 == 1
                ReadTextFile GxGyProb $progdir\View_$iter.log
                CloseTextFile 1
                RemoveFile $progdir\View_$iter.log
                Break
            Else
                Echo Failed to read text file @log in YONEOLOCKER
            EndIf

            Delay 0.3s
        EndLoop

        RemoveFile $progdir\View_$iter.jpg
        prob = $GxGyProb[3]

        if $prob == 0
            Echo Can't detect any holes
            Echo ===> Hole align failed....
            Echo ===> Skip this item.
            SetImageShift 0 0 0 1
            # Failed
            Exit
        EndIf

        gdx = $GxGyProb[1] * $xdim1 * $binning1
        gdy = $GxGyProb[2] * $ydim1 * $binning1
        CameraToStageMatrix 0
        dx = ($gdx * $repval1 + $gdy * $repval2) * $flipX * 2.0  # [nm] works well for CRYO ARM 300. 1.4 for CryoARM200
        dy = ($gdx * $repval3 + $gdy * $repval4) * $flipY * 2.0  # [nm] -2 works well for CRYO ARM 300. 1.4 for CryoARM200

        MoveStage $dx $dy

        # For item realign
        diff_x = $diff_x + $dx
        diff_y = $diff_y + $dy

        # Conver from [um] to [nm]
        dx = $dx * 1000
        dy = $dy * 1000
        holeshift = sqrt ( $dx * $dx + $dy * $dy ) # [nm]

    Else
        Echo ===> Hole detection by Template match.

        If $iter > 1
            ResetImageShift
            ReportSpecimenShift sp_x0 sp_y0
            V
        EndIf

        AlignTo $template_buffer
        ReportAlignShift

        dx = $RepVal5 * $flipX # Shift on specimen X axis [nm]
        dy = $RepVal6 * $flipY # Shift on specimen Y axis [nm]
        holeshift = sqrt ( $dx * $dx + $dy * $dy )

        # For item realign
        CallFunction Funcs::GetAppendedShift $sp_x0 $sp_y0
        diff_x = $repVal1
        diff_y = $repVal2
    EndIf

    If $holeshift >= 500
        align_err_count = $align_err_count + 1
    EndIf

    If $align_err_count >= 5
        SetImageShift 0 0
        skip_message @= "Skipped. Hole alignment failure. Too many big move."
        CallFunction Funcs::AnnotateSkipItem $skip_message
        Exit
    EndIf

    lastShiftX = $dx / 1000
    lastShiftY = $dy / 1000

    return $diff_x $diff_y $holeshift $lastShiftX $lastShiftY 

EndFunction

#######################################################

    Function GetAppendedShift 2 0 sp_x0 sp_y0
        
        If $workflowType != 1 
            diff_x = 0
            diff_y = 0
            Return $diff_x $diff_y
        EndIf

        IsVariableDefined diff_x
        If $repVal1 == 0
            diff_x = 0
            diff_y = 0
        EndIf

        ReportSpecimenShift sp_x1 sp_y1
        diff_x = $diff_x + ( $sp_x1 - $sp_x0 ) * $flipX
        diff_y = $diff_y + ( $sp_y1 - $sp_y0 ) * $flipY

        Return $diff_x $diff_y

    EndFunction

#######################################################

    Function ResetImageShiftWithBadStage 2 0 totalX totalY

        # Under development...

        CallFunction EMProperties::LoadAdditionalProperties

        totalX = $totalX / 1000
        totalY = $totalY / 1000

        maxShortX = 0.2
        maxShortY = 0.2

        SetImageShift 0 0

        totalDist = sqrt ( $totalX * $totalX + $totalY * $totalY )
        moveDist = sqrt ( $maxShortX * $maxShortX + $maxShortY * $maxShortY )

        maxIter = NEARINT ($totalDist / $moveDist) + 1

        Loop maxIter
            moveX = $maxShortX * -1
            moveY = $maxShortX * -1
            If ABS ($totalX) <= ABS ($maxShortX)
                moveX = $totalX * -1
            EndIf
            If ABS ($totalY) <= ABS ($maxShortY)
                moveY = $totalY * -1
            EndIf

            MoveStage $moveX $moveY

            totalX = $totalX - ABS ($moveX)
            totalY = $totalY - ABS ($moveY)

            If ($totalX <= 0) AND ($totalY <= 0)
                Break
            EndIf
        EndLoop
    
    EndFunction

#######################################################

    Function ReadHoleImage 0 0

        CallFunction EMProperties::LoadAdditionalProperties

        ReportNavFile 1
        NAVIGATOR_PATH = $repVal3
        file_name @= hole_template.mrc
        hole_file1 = $NAVIGATOR_PATH$file_name

        path_to_HoleImage @= $WORKING_DIR_PATH\Data\HoleImage
        hole_file2 = $path_to_HoleImage\hole_template.mrc

        # ====== Main =======

        Echo ====== Start AlignToHole =======

        # Set View mode of LD
        SetLowDoseMode 1
        GoToLowDoseArea V

        # Read hole image
        open_again = 0

        Echo $template_buffer
        Echo $hole_file2

        Try
            ReadOtherFile 0 $template_buffer $hole_file1
        Catch
            Echo ===> Cannot find $hole_file1
            Echo ===> Try to open $hole_file2
            ## Temporaly
            ReadOtherFile 0 $template_buffer $hole_file2
        EndTry 

    EndFunction


############################################################

Function SetAtlasIllumination 1 0 CLapt_sizeID

    CallFunction EMProperties::LoadAdditionalProperties

    SetMag $mag_atlas
    Delay 5 sec

    #in the case of CRYO ARM 300, open aperture
    If $Arm300I == 1       
       RunInShell $setCLapt 0 0
       RunInShell $setCLapt 1 0
    Endif 

    RunInShell $setCLapt $CLapt_type $CLapt_sizeID

    # Remove OL apt
    RunInShell $setOLapt $OLapt_type 0

    # Remove Slit
    CallFunction Funcs::CustomSetSlitIn 0

    # Set spot size
    If $spot_atlas <= 0
       spot_atlas = $default_spot_atlas 
    Endif 

    SetSpotSize $spot_atlas

    SetPercentC2 $brightness_atlas # 100%

    SetEucentricFocus
    ResetDefocus

EndFunction

############################################################

Function SetSquareIllumination 1 0 CLapt_sizeID

    CallFunction EMProperties::LoadAdditionalProperties

    #in the case of CRYO ARM 300, open aperture
    IF $Arm300I == 1       
       RunInShell $setCLapt 0 0
       RunInShell $setCLapt 1 0
    Endif 

    # Set CL apt
    RunInShell $setCLapt $CLapt_type $CLapt_sizeID

    # Remove OL apt
    RunInShell $setOLapt $OLapt_type 0

    CallFunction Funcs::CustomSetSlitIn 0
    SetSpotSize $spot_square
    SetPercentC2 $brightness_square 

    SetEucentricFocus
    ResetDefocus

EndFunction

############################################################

Function AnnotateSkipItem 0 1 message_skipped

    IsVariableDefined workflowType
    If $repVal1 == 0
        Echo There is no item for acquisition.
        Return
    EndIf
        
    If $workflowType == 0
        Echo There is no item for acquisition.
        Return
    EndIf

    ReportNavItem 
    nav_idx = $repVal1
    label_skipped @= $navLabel-skipped
    Echo ===> Item_$navLabel : $message_skipped
    ChangeItemLabel $nav_idx $label_skipped
    ChangeItemNote $nav_idx $message_skipped
    ChangeItemColor $nav_idx 3
    SkipAcquiringNavItem

EndFunction


#######################################################

Function ReportLowDose_by_Char 0 0

    ReportLowDose
    If $repVal2 == 0
        area = V
    ElseIf $repVal2 == 1
        area = F
    ElseIf $repVal2 == 2
        area = T
    ElseIf $repVal2 == 3
        area = R
    ElseIf $repVal2 == 4
        area = S
    EndIf

    Return $area

EndFunction

#######################################################

Function TakeScreenImage 0 1 area

   CallFunction EMProperties::LoadAdditionalProperties
   SelectCamera $screenCamID
   $area
   CropCenterToSize A $FlashSizeX $FlashSizeY
   SelectCamera $mainCamID

EndFunction

############################################################

Function GetFovSize 0 1 area

    CallFunction EMProperties::LoadAdditionalProperties

    GoToLowDoseArea $area
    CameraProperties $mainCamID
    width = $repVal1
    height = $repVal2
    pixSize = $repVal5

    fovSize = SQRT ($width * $width + $height * $height ) * $pixSize / 1000
    Echo ===> Main detector FOV at $area is $fovSize [um]
    Return $fovSize

EndFunction

############################################################

Function TakeRecord

    recNum := $recNum + 1
    ReportTickTime
    recTime = $repVal1 - $iniTime
    recTime = ROUND $recTime 0
    fileNameIn @= $recNum_SlitIn_$recTimes.tif
    fileNameOut @= $recNum_SlitOut_$recTimes.tif
    # s for [sec]

    # Log message
    If $slitOut == 1
        Echo Recoding, $recTime [s], $fileNameIn, $fileNameOut
    Else
        Echo Recoding, $recTime [s], $fileNameIn
    EndIf    

    # Open Valve and wait for 5sec
    SetBeamBlank 1
    SetColumnOrGunValve 1
    Delay 5 sec

    # Unblank and take an image
    SetBeamBlank 0
    R
    SaveToOtherFile A TIF LZW $fileNameIn

    # Slit out if needed
    If $slitOut == 1
        CallFunction Funcs::CustomSetSlitIn 0
        R
        SaveToOtherFile A TIF LZW $fileNameOut
    
    EndIf

    ReportTickTime
    lastRec := $repVal1

    # Beam blank and close valve
    SetBeamBlank 1
    SetColumnOrGunValve 0
    CallFunction Funcs::CustomSetSlitIn 1

    Echo --------------------------

EndFunction

###########################################

    Function WaitForRefilling2 0 0

        AreDewarsFilling  # report 1 for stage tank. report 2 for transfer tank.

        If $repVal1 >= 1
           
            ReportTickTime
            refillTime = $repVal1 - $iniTime
            refillTime = ROUND $refillTime 0
            Echo Refill, $refillTime [s]

            LongOperation RS 0 RT 0

            # Flashing at a time
            If $flash_when_refill == 1
                LongOperation FF 0
                ReportTickTime
                last_flashing := $repVal1
                flashed := 1
            EndIf

            # Dark ref at a time
            If ($darkRef_when_refill == 1) AND ($update_dark == 1)
                LongOperation Da 0
                ReportTickTime
                last_dark := $repVal1
                dark_updated := 1
            EndIf

            refilled := 1
            
            SetColumnOrGunValve 0

            Echo ===> Refilling and pressurizing...
            Loop 60

                Delay 30 sec
                AreDewarsFilling 

                If $repVal1 == 0
                    Break
                EndIf

                #Echo Still refilling

            EndLoop

            Echo ===> Waiting for the additional settling time of $delay_after_refill [min]
            Delay $delay_after_refill min
            Echo ===> LN2 refill completed.
            
            Echo --------------------------

        EndIf

    EndFunction
#######################################################

    Function CustomReportEnergyFilter 0 0 

        CallFunction EMProperties::LoadAdditionalProperties
        
        slitWidth = -1
        energyLoss = -1
        slitInOut = -1

        If $hasOmegaFilter == 0
            Echo ===> This scope does not have energy filter.
            Return $slitWidth $energyLoss $slitInOut
        EndIf

        ReportEnergyFilter
        slitWidth = $repVal1
        energyLoss = $repVal2
        slitInOut = $repVal3
        Return $slitWidth $energyLoss $slitInOut
        

    EndFunction

#######################################################

    Function CustomSetSlitIn 1 0 slitInOut

        CallFunction EMProperties::LoadAdditionalProperties
        If $hasOmegaFilter == 0
            Echo ===> This scope does not have energy filter.
            Echo ===> Does not apply "SetSlitIn 1"
            Return
        EndIf
        SetSlitIn $slitInOut

    EndFunction

#######################################################

    Function ResetStandardFoucs
         GoToLowDoseArea R
         SetEucentricFocus 
         ResetDefocus
         UpdateLowDoseParams R
    EndFunction

##########################################################

    Function SpecingAngleToImageShiftVal 2 0 spacing angle
       
       IS_X = $spacing * cos ($angle)
       IS_Y = $spacing * sin ($angle)

       Return $IS_X $IS_Y

    EndFunction

##########################################################

    Function ImageShiftValToSpecingAngle 2 0 ISX ISY
       
       spacing = SQRT ( $ISX * $ISX + $ISY * $ISY )
       angle = ATAN2 ( $ISY $ISX )

       Return $spacing $angle

    EndFunction

##########################################################

Function WillZExeedRange 1 0 Zmove

   CallFunction EMProperties::LoadAdditionalProperties

   ReportStageXYZ
   currentZ = $repVal3

    nextZ = $currentZ - $Zmove   

    If ($nextZ < $safty_z_lower) OR ($safty_z_upper < $nextZ)
       Return 1
    EndIf

    Return 0

EndFunction

##########################################################

Function CustomEarlyReturnNextShot 1 0 value

    Try
        EarlyReturnNextShot $value
     Catch
        Echo ===> "EarlyReturnNextShot " only works on K2/K3. 
     EndTry

EndFunction

##########################################################

    Function BubbleSort 1 0 arr

        change = 1
        searchRange = $#arr - 1

        # psuedo while (change)
        Loop 9999999
            If $change == 0
                Break
            EndIf

            change = 0
            Loop $searchRange i
                If $arr[$i] > $arr[$i+1]
                    arr_tmp = $arr[$i]
                    arr[$i] = $arr[$i+1]
                    arr[$i+1] = $arr_tmp
                    change = 1
                EndIf
            EndLoop
        EndLoop

        Return $arr

    EndFunction

#################################################
EndMacro
Macro	31
ScriptName ImageAcquisition

################################################################

Function AquireMultiHoles 0 0

        process @= AquireMultiHoles
        ReportTickTime
        start_ticks = $repVal1

        # ---- Set initial parameters ----
        IsVariableDefined workflowType
        If $repVal1 == 0
            workflowType = 0
        EndIf

        # Data Collecion
        If $workflowType == 1
           GoToLowDoseArea R
           If $stop_display_R == 1
              CallFunction Funcs::CustomEarlyReturnNextShot 0
           Else
              CallFunction Funcs::CustomEarlyReturnNextShot $DisplayReturn
           Endif
        # Screening
        ElseIf $workflowType == 2
           CallFunction Funcs::CustomEarlyReturnNextShot  -1
        # Other
        Else
           save_R = 0
           measure_thickness = 0 #have to check in screening
        Endif 

        # ---- Multiplehole shot by SerialEM implemened ----
        If $use_multiR == 2
            MultipleRecords
            IS_array = { 0 }
        # ---- Set IS values for non-SerialEM implemented ----
        Else
            If ( $PATTERN == 0 ) AND ( $LAYER > 0 ) 
                CallFunction ImageAcquisition::SetISForMultiHole_Even
            Else
                CallFunction ImageAcquisition::SetISForMultiHole_Odd
            EndIf
            IS_array = $repVal1
        EndIf

        ReportDefocus origin_defocus   

        # ---- Multihole shot by non-SerialEM implemened ----
        len_iss = $#IS_array
        DoLoop idx 1 $len_iss 2

            If $use_multiR == 2
                Break
            EndIf

            nx = $IS_array[$idx]
            idx2 = $idx + 1
            ny = $IS_array[$idx2]
            ImageShiftByMicrons $nx $ny 0 $BTtoIS

           
            ########## Function from AquireHole ##########
            AreDewarsFilling
            If $repVal1 >= 1
               CallFunction Funcs::WaitForRefilling
            Endif 

            # Set defocus for tilted stage
            ReportSpecimenShift sp_x sp_y
            If $do_tilt == 1
               CallFunction ChangeFocusForTilt $sp_y
            Endif 
            
            # --- For CheckMultiHole ---
            If $workflowType == 0
               cnt = $cnt + 1
               Echo ===> No. $cnt
               
               If $LD_mode == 0
                  V
                  SaveToOtherFile A JPG NONE $NAVIGATOR_PATHCheckMultiHole\View_$cnt.jpg
               Else
                  If $use_multiR == 0             
                     R
                  ElseIf $use_multiR == 1
                     MultipleRecords -9 -9 -9 0 0
                  Endif 
                  SaveToOtherFile A JPG NONE $NAVIGATOR_PATHCheckMultiHole\Record_$cnt.jpg
                  
                  If $check_coma == 1
                     FixComaByCTF 1 1
                  Endif 
               Endif 
               sp_x_round = ROUND $sp_x 2
               sp_y_round = ROUND $sp_y 2
               Echo ===> ImageShiftX:$sp_x_round [um], ImageShiftY:$sp_y_round [um]
               Continue 
            Endif 
            # 1st shot for ice thickness
            If $idx == 1 AND $measure_thickness == 1
               CallFunction Funcs::CustomEarlyReturnNextShot  -1
            Endif
            
            # --- For DataCollection ---
            If $use_multiR == 0
               R
            ElseIf $use_multiR == 1
               MultipleRecords -9 -9 -9 0
            Endif 
            If $save_R == 1
               SaveToOtherFile A JPG NONE $log_dirR\Record_Item$item_label_Square$map_label_$acq_count.jpg
               copy AF F
               SaveToOtherFile F JPG NONE $log_dirR\Record_Item$item_label_Square$map_label_$acq_count_FFT.jpg
               If $workflowType == 2
                  img_info_file @= $log_dirR\Record_Item$item_label_Square$map_label_$acq_count.jpg
                  #SaveToOtherFile A MRC NONE $log_dirR\Record_Item$item_label_Square$map_label_$acq_count.mrc
                  ReduceImage A 2 #binning 4
                  SaveToOtherFile A JPG NONE $log_dirR\Record_Item$item_label_Square$map_label_$acq_count.jpg
               EndIf
               acq_count := $acq_count + 1 
            Endif 
            # 1st shot for ice thickness
            If $idx == 1 AND $measure_thickness == 1
               ElectronStats A
               electron_count_slitIn = $repVal5
            Endif
            acquired_image_num := $acquired_image_num + 1
            
         EndLoop 


        SetDefocus $origin_defocus 

        # completely reset IS and BT
        SetImageShift 0 0 0 $BTtoIS
        #SetBeamTilt $btux1 $btuy1
        #SetBeamShift $bsx1 $bsy1

        Echo -----> Done
        ReportTickTime
        end_ticks = $repVal1
        CallFunction Funcs::ElapsedTimeMonitor $start_ticks $end_ticks $process

     EndFunction

#######################################################

Function SetISForMultiHole_Odd 0 0
   
   if $LAYER == 0
      nx = 0
      ny = 0
      If $use_offshot == 1
         nx = $nx + $n2x
         ny = $ny + $n2y
      Endif 
      IS_array = { $nx $ny }
   Endif 

   If $LAYER > 0
      nx = 0
      ny = 0
      If $use_offshot == 1
         nx = $nx + $n2x
         ny = $ny + $n2y
      Endif 
      Vh_x = $IS_RAD1_h * cos ( $IniAng_h )
      Vh_y = $IS_RAD1_h * sin ( $IniAng_h )
      Vv_x = $IS_RAD1_v * cos ( $IniAng_v )
      Vv_y = $IS_RAD1_v * sin ( $IniAng_v )
      IS_array = { $nx $ny }

      If $TT != 0
         Vh_y = $Vh_y * cos ( $TT )
         Vv_y = $Vv_y * cos ( $TT )
      EndIf
      
      Loop $LAYER idx
         
         nx = $Vh_x
         ny = $Vh_y
         AppendToArray IS_array $nx
         AppendToArray IS_array $ny

         side1 = 2 * $idx - 1
         Loop $side1
            nx = $Vv_x
            ny = $Vv_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
         side2 = 2 * $idx
         Loop $side2
            nx = -1 * $Vh_x
            ny = -1 * $Vh_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
         side3 = 2 * $idx
         Loop $side3
            nx = -1 * $Vv_x
            ny = -1 * $Vv_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
         side4 = 2 * $idx
         Loop $side4
            nx = $Vh_x
            ny = $Vh_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
      EndLoop
      
   EndIf

   Return $IS_array
   
EndFunction

################################################################

Function SetISForMultiHole_Even 0 0
   
   If $LAYER > 0
      
      nx = 0
      ny = 0
      Vh_x = $IS_RAD1_h * cos ( $IniAng_h )
      Vh_y = $IS_RAD1_h * sin ( $IniAng_h )
      Vv_x = $IS_RAD1_v * cos ( $IniAng_v )
      Vv_y = $IS_RAD1_v * sin ( $IniAng_v )
      
      ### for tilt
      If $TT != 0
         Vh_y = $Vh_y * cos ( $TT )
         Vv_y = $Vv_y * cos ( $TT )
      Endif 
      ###
      
      # Move to first layer
      nx = $Vh_x / 2 + $Vv_x / 2
      ny = $Vh_y / 2 + $Vv_y / 2
      If $use_offshot == 1
         nx = $nx + $n2x
         ny = $ny + $n2y
      Endif 
      IS_array = { $nx $ny }
      
      Loop $LAYER idx
         
         # Move to next layer
         If $idx > 1
            nx = $Vh_x
            ny = $Vh_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         Endif 
         
         # Move around current layer
         side1 = 2 * $idx - 2
         Loop $side1
            nx = $Vv_x
            ny = $Vv_y
            ImageShiftByMicrons $nx $ny 0 $BTtoIS
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
         side2 = 2 * $idx - 1
         Loop $side2
            nx = -1 * $Vh_x
            ny = -1 * $Vh_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
            
         EndLoop

         side3 = 2 * $idx - 1
         Loop $side3
            nx = -1 * $Vv_x
            ny = -1 * $Vv_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
         side4 = 2 * $idx - 1
         Loop $side4
            nx = $Vh_x
            ny = $Vh_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 
         
      EndLoop
      
   EndIf
   
EndFunction

#######################################################

Function SetISForMultiHole_Hex 0 0
   
   If $LAYER > 0
      
      nx = 0
      ny = 0
      If $use_offshot == 1
         nx = $nx + $n2x
         ny = $ny + $n2y
      Endif 
      IS_array = { $nx $ny }
      V1_x = $IS_RAD1_1 * cos ( $IniAng_1 )
      V1_y = $IS_RAD1_1 * sin ( $IniAng_1 )
      V2_x = $IS_RAD1_2 * cos ( $IniAng_2 )
      V2_y = $IS_RAD1_2 * sin ( $IniAng_2 )
      V3_x = $IS_RAD1_3 * cos ( $IniAng_3 )
      V3_y = $IS_RAD1_3 * sin ( $IniAng_3 )
      
      ### for tilt
      If $TT != 0
         V1_y = $V1_y * cos ( $TT )
         V2_y = $V2_y * cos ( $TT )
         V3_y = $V3_y * cos ( $TT )
      Endif 
      ###
      
      Loop $LAYER idx
         
         # Move to next layer
         nx = $V1_x
         ny = $V1_y
         AppendToArray IS_array $nx
         AppendToArray IS_array $ny
         
         # Move around current layer
         side0 = $idx - 1
         Loop $side1
            nx = $V2_x
            ny = $V2_y                   
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop 

         side1 = $idx
         Loop $side1
            nx = $V3_x
            ny = $V3_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop
                
         side2 = $idx
         Loop $side2
            nx = -1 * $V1_x
            ny = -1 * $V1_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny  
         EndLoop
         
         side3 = $idx
         Loop $side3
            nx = -1 * $V2_x
            ny = -1 * $V2_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
         EndLoop
         
         side4 = $idx
         Loop $side4
            nx = -1 * $V3_x
            ny = -1 * $V3_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny          
         EndLoop
         
         side5 = $idx
         Loop $side5
            nx = $V1_x
            ny = $V1_y
            AppendToArray IS_array $nx
            AppendToArray IS_array $ny
            
         EndLoop
         
      EndLoop
      
   EndIf
   
EndFunction

#######################################################

    Function ChangeFocusForTilt 1 0 sp_y

        If $TT != 0

            additional_defocus = -1 * $sp_y * tan ( $TT )

            setting_defocus = $origin_defocus + $additional_defocus

            #If $apply_defocus_offset == 1
            #    SetDefocus $defocus_offset
            #EndIf

            SetDefocus $setting_defocus

            Echo ===> Defocus : $setting_defocus [um]

        EndIf

    EndFunction

#######################################################
EndMacro
Macro	32
ScriptName Controller

#===================================================================
# This script is part of the "SPADataCollection". 
# Controlls AutoFocus, StageDrift, ZLP refinement.
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion repository.
# Modified by TF and FM.
#===================================================================

#############################################################

    Function FocusControl 0 0

        # ========== PreSet before autofocus ==========
        # Check, if the stage moved to a different grid square at a different Z height:
        ReportStageXYZ
        NEWX = $repVal1
        NEWY = $repVal2
        NEWZ = $repVal3

        If ABS ($NEWX - $LASTX) > $stageX_limit_for_focus
            Echo Large X change detected. LASTX = $LASTX,  NEWX = $NEWX.  Requires new focussing.
            FOCUSCOUNTER := 0
            group_FLAG := 1
        EndIf

        If ABS ($NEWY - $LASTY) > $stageY_limit_for_focus
            Echo Large Y change detected. LASTY = $LASTY,  NEWY = $NEWY.  Requires new focussing.
            FOCUSCOUNTER := 0
            group_FLAG := 1
        EndIf


        #  if you wish, focusing before stage tilt anyway
        If $focus_before_tilt == 1
            Echo ---> Focusing will be performed before stage tilt anyway. 

        #  otherwise skip for the tilt stage (but if it is the first point on a square, do autofocus):
        Else 
            If ($do_tilt == 1) AND ($group_FLAG == 0)
                ReportTiltAngle
                curr_angle = $repVal1
                diff_angle = ABS ( $TT - $curr_angle )

                If $diff_angle > 3
                    Echo ===> Here is not the inital point of group.
                    Echo ===> Target tilt is $TT [degree], while current angle is $curr_angle [degree].
                    Echo ===> Focusing is skipped.
                    Return
                EndIf
            EndIf

        EndIf

        # ========== BeamCentering Process ==========
        CallFunction Controller::CenterBeamOnTrial $beamCenterEachHole

        # ========== AutoFocus Process ============
        If $FOCUSCOUNTER > 1
            Echo ===> Autofocus is skipped.
            Return
        EndIf

        # AutoFocus is performed only when FOCUSCOUNTER == 0 or 1
        Echo ===> Focussing on this one..., Focus Counter = $FOCUSCOUNTER
        
        # Register the current coordinate as the old coordinate.
        LASTX := $NEWX
        LASTY := $NEWY
        LASTZ := $NEWZ

        # If focus_problem_counter get to 3, apply standard defocus and reset beamshift.
        If $focus_problem_counter > 3
            Echo Trying to save the beam:
            SetEucentricFocus 
            SetBeamShift $good_beamshift_x $good_beamshift_y
            focus_problem_counter := 0
            FOCUSCOUNTER := 0
        EndIf

        # Set target defocus
        If $focused == 0
            CallFunction Funcs::CycleTargetDefocus
            ReportTargetDefocus original_TD
            
            If ($do_tilt == 1) AND ($TT != 0) AND ($use_eucentric_height == 1)
                Echo ===> Use eucentric height for stage tilt.
                Echo ===> Target defocus for Z is set to $eucentric_height [um].
                SetTargetDefocus $eucentric_height
            EndIF

            FocusChangeLimits -70 70
        EndIf

        # Irradiation to burn ice and get high signal from carbon.
        If $irradiation_time > 0
            Echo ---> Irradiating $irradiation_time sec
            GoToLowDoseArea F
            SetBeamBlank 0
            Delay $irradiation_time sec
            SetBeamBlank 1
        Else
            Echo ---> No irradiation.
        EndIf

        # Start autoFocus
        F
        ReportMeanCounts A
        mean_count = $repVal1
        If $mean_count < 3
            Echo ---> No beam. Skip this area.
            Exit
        EndIf

        If $save_F == 1
            SaveToOtherFile A JPG NONE $log_dirF\Focus_Item$item_label_Square$map_label_$acq_count.jpg
        EndIf

        If $focus_method == 1 OR ($group_FLAG == 1) # Z
            ReportTiltAngle curr_angle 
            If ABS ( $curr_angle ) < 3 # If the stage is almost flat (No tilt)
                CallFunction CustomAutoFocus::AutoFocus_byZ
                # Reset target defocus for tilted data collection after adjusting to eucentric height.
                SetTargetDefocus $original_TD
            Else
                If $stop_OLfocusing == 1 # This stops OL focusing after stage tilt anyway.
                    Echo ===> OL focusing is not applied...
                Else
                    CallFunction CustomAutoFocus::AutoFocus_byOL
                EndIf
            EndIf
        ElseIf ($focus_method == 0) # OL
            CallFunction CustomAutoFocus::AutoFocus_byOL
        EndIf
        focused = 1

        If $save_F == 1
            SaveToOtherFile A JPG NONE $log_dirF\Focus_Item$item_label_Square$map_label_$acq_count.jpg
        EndIf

        FOCUSCOUNTER := $focusEachHole
        ReportBeamShift
        good_beamshift_x := $repVal1
        good_beamshift_y := $repVal2
        focus_problem_counter := 0

        Echo ---> good beamshift = $good_beamshift_x, $good_beamshift_y

        # Beam Centering by F after Focusing
        If $beamCentering_afterFocus == 1
            F
            ReportMeanCounts A
            mean_count = $repVal1

            If $mean_count > 3
                Echo ---> BeamCentering...
                CenterBeamFromImage
            EndIf
        EndIf

    EndFunction

#############################################################

    Function DriftControl 0 0

        If $do_drift_control == 1

            If $do_tilt == 1
                ReportTiltAngle
                curr_angle = $repVal1
                diff_angle = ABS ( $TT - $curr_angle )

                If $diff_angle > 3
                    Echo ===> Target tilt is $TT [degree], while current angle is $curr_angle [degree].
                    Echo ===> Drift control is skipped.
                    Return
                EndIf

                If $drift_ctrl_when_tilt == 1
                    CallFunction Funcs::WaitForDrift $drift_crit $drift_shot
                    Echo ===> Additional settling time for the tilted stage. $tilt_settling_time [sec]
                    Delay $tilt_settling_time sec
                    Return
                EndIf
            EndIf


            If $once_every_group == 1
                If $group_FLAG == 1
                    CallFunction Funcs::WaitForDrift $drift_crit $drift_shot
                EndIf
            Else
                CallFunction Funcs::WaitForDrift $drift_crit $drift_shot
            EndIf

            Echo ===> Additional settling time $additional_settling_time [sec]
            Delay $additional_settling_time sec

        EndIf

    EndFunction

#############################################################

    Function TiltControl 0 0

        If $do_tilt == 1

            Echo ---> Tilt operation is ON.

            If $TT != 0
                Echo ---> Target tilt is $TT [degree].
                Echo ---> Performe tilt operation.

                ReportStageXYZ 
                x_saved = $repVal1
                y_saved = $repVal2
                z_saved = $repVal3

                CallFunction CustomTilt::TiltOnHole

                CallFunction CustomTilt::AlignToTiltHole

                CallFunction FocusControl

                CallFunction DriftControl
            EndIf

        EndIf

    EndFunction

#############################################################

    Function ZLPControll 0 0

        If $do_refineZLP == 1

            If $ZLP_when_flash == 1
                If $flashed == 1
                    CallFunction ZLPAlignByFL::Core $search_range $search_step $ZLP_thld_ratio $area
                    ZLP_aligned := 1
                Else
                    ZLP_aligned := 0
                EndIf
            Else
                IsVariableDefined last_ZLP
                If $repVal1 == 0
                    last_ZLP := $initial_ticks
                EndIf
                
                ReportTickTime current_ticks
                ZLP_elapsed_ticks = $current_ticks - $last_ZLP
                ZLP_elapsed_tmp = $ZLP_elapsed_ticks / 3600
                Echo ---> Elapsed time for ZLP : $ZLP_elapsed_tmp [hr]

                If $ZLP_elapsed_ticks >= $ZLPInterval
                    CallFunction ZLPAlignByFL::Core $search_range $search_step $ZLP_thld_ratio $area
                    ReportTickTime
                    last_ZLP := $repVal1
                    ZLP_aligned := 1
                Else
                    ZLP_aligned := 0
                EndIf
            EndIf

        Else
             ZLP_aligned := 0
        EndIf

    EndFunction

#############################################################

    Function CenterBeamOnTrial 1 0 beamCenterEachHole

        If $centerBeamCounter > 1
            Echo ===> Skip BeamCentering...
            centerBeamCounter := $centerBeamCounter - 1
            Return
        EndIf

        # BeamCentering is performed only when centerBeamCounter == 0 or 1
        Echo ===> Beam Centering on this one..., CenterBeamCounter = $centerBeamCounter

        # Beam Centering by T
        T
        ReportMeanCounts A
        mean_count = $repVal1
        If $save_T == 1
            SaveToOtherFile A JPG NONE $log_dirT\Trial_beforeCentering_Item$item_label_Square$map_label_$acq_count.jpg
        EndIf

        centerBeamCounter := $beamCenterEachHole

        # If the image is bright, do beam centering
        If $mean_count > 3

            ReportBeamShift init_beamX init_BeamY
            Echo ---> BeamCentering...
            CenterBeamFromImage
            T
            ReportMeanCounts A
            mean_count = $repVal1

            If $mean_count < 3
                SetBeamShift $init_beamX $init_BeamY
                skip_message @= "Skipped. Beam was not detected in Trial image."
                CallFunction Funcs::AnnotateSkipItem $skip_message
                SkipAcquiringNavItem
                Exit
            EndIf

        EndIf

        If $save_T == 1
            SaveToOtherFile A JPG NONE $log_dirT\Trial_afterCentering_Item$item_label_Square$map_label_$acq_count.jpg
        EndIf

        # If the image is black, increase focus_problem_counter.
        If $mean_count < 3
            Echo Trial image is black. MeanCounts was $repVal1.
            focus_problem_counter := $focus_problem_counter + 1
            echo FOCUS problem counter = $focus_problem_counter

            centerBeamCounter := 0
        Else
            focus_problem_counter := 0
        EndIf

    EndFunction

#############################################################
EndMacro
Macro	33
ScriptName CustomAutoFocus

#===================================================================
# This script is part of the "SPADataCollection". 
# Performes auto focus during data collection.
# --------------------------------------------------------------------------------------------------------------------
# Originally imported from Nexperion repository.
# Modified by TF and FM.
#===================================================================

#######################################################

    Function FixInvalidDefocusValue 0 0

        ReportTargetDefocus
        target_defocus = -1 * ABS ($repVal1)
        SetTargetDefocus $target_defocus

    EndFunction

#######################################################

    Function AutoFocus_byZ 0 0

        CallFunction EMProperties::LoadDefaultFocusParams

        process @= AutoFocus_byZ
        ReportTickTime
        start_ticks = $repVal1

        SetEucentricFocus

        If $focus_method == 1
            # To always perform drift control after Z-height chenge.
            once_every_group = 0
        EndIf

        ReportStageXYZ init_x init_y init_z

        Echo =============================
        Echo Start Auto Focusing
        Echo Focus method : By Z
        Echo =============================

        Loop $max_focusZ_iter iter

            CallFunction Funcs::WaitForRefilling

            ReportTargetDefocus target_defocus

            If $focusOnRec == 1
                G -1 -1
            Else
                G -1
            EndIf

            FFT A
            ReportAutofocus measured_defocus
            ReportStageXYZ setting_x setting_y setting_z
            defocus = $target_defocus - $measured_defocus
            relax_z1 = ( $defocus / ABS ($defocus) ) * $backlash_z
            relax_z2 = -1 * ( $defocus / ABS ($defocus) ) * $backlash_z
            range = ABS ($defocus)

            Echo ------------------------------------------------
            Echo Autofocus iter $iter
            Echo Target = $target_defocus [um]
            Echo Measured = $measured_defocus [um]
            Echo Need change ---> $defocus [um]

            # Success
            #If ($range <= $focus_error) AND ($measured_defocus <= $focus_th_low) 

            If ($range <= $focus_error)
                Echo ===> Focusing was succeeded.
 
                If $updata_Z_afterFocus == 1
                    UpdateGroupZ
                    UpdateItemZ
                EndIf

                Break

            # Failed
            ElseIf ( ABS ($measured_defocus) <= 0.0001 ) OR ( ABS ($measured_defocus) >= 200.0 ) OR ($setting_z <= $safty_z_lower) OR ($safty_z_upper <= $setting_z)
                MoveStageTo $init_x $init_y $init_z
                FOCUSCOUNTER := 0
                Echo !!!!!!!!!!!!!!!!!!!!!!!!!!!  Error in Defocus by Z, Caution values ==> ( $measured_defocus) <= 0.0001 ) OR ($measured_defocus) >= 200.0 ) OR ($setting_z <= $safty_z_lower) OR ($safty_z_upper <= $setting_z) !!!!!!!!!!!!!!!!!!!!!!!!!!!  
                skip_message @= "Skipped. Failuer of Auto Focus by Z."
                CallFunction Funcs::AnnotateSkipItem $skip_message
                SkipAcquiringNavItem
                Exit

            # Adjust focus by Z
            Else
                Echo ===> Focus is adjusted by stage movement.

                setting_z = $setting_z + $defocus * 0.8 + $relax_z1
                MoveStageTo $setting_x $setting_y $setting_z
                Echo ---> Move to $setting_z [um]
                Echo ---> Relaxing and Settling
                MoveStage 0 0 $relax_z2
                Delay $z_settle_time sec

                If $iter == $max_focusZ_iter
                    skip_message @= "Skipped. Failuer of Auto Focus by Z."
                    CallFunction Funcs::AnnotateSkipItem $skip_message
                    SkipAcquiringNavItem
                    Exit
                EndIf

            EndIf

        EndLoop

        ReportTickTime
        end_ticks = $repVal1
        CallFunction Funcs::ElapsedTimeMonitor $start_ticks $end_ticks $process

    EndFunction

#######################################################

    Function AutoFocus_byOL 0 0

        CallFunction EMProperties::LoadDefaultFocusParams

        process @= AutoFocus_byOL
        ReportTickTime
        start_ticks = $repVal1

        SetEucentricFocus

        ReportTiltAngle curr_angle
        ReportDefocus initial_defocus

        defocus_total = 0

        ReportStageXYZ init_x init_y init_z

        Echo =============================
        Echo Start Auto Focusing
        Echo Focus method : By OL
        Echo =============================

        Loop $max_focus_iter iter

            CallFunction Funcs::WaitForRefilling

            ReportTargetDefocus target_defocus

            If $focusOnRec == 1
                G -1 -1
            Else
                G -1
            EndIf

            FFT A
            ReportAutofocus measured_defocus
            ReportDefocus setting_defocus
            ReportStageXYZ setting_x setting_y setting_z
            defocus = $target_defocus - $measured_defocus
            # defocus_total = $defocus_total + $defocus
            range = ABS ($defocus)

            Echo ------------------------------------------------
            Echo Autofocus iter $iter
            Echo Target = $target_defocus [um]
            Echo Measured = $measured_defocus [um]
            Echo Need change ---> $defocus [um]

            # Success
            If ($range <= $focus_error) AND ($measured_defocus <= $focus_th_low)
                Echo ===> Focusing was succeeded.

                If $updata_Z_afterFocus == 1
                    UpdateGroupZ
                    UpdateItemZ
                EndIf

                Break

            # Failed
            ElseIf ( ABS ($measured_defocus) <= 0.0001 ) OR ( ABS ($measured_defocus) >= 200.0 ) OR ($setting_z <= $safty_z_lower) OR ($safty_z_upper <= $setting_z)
                Echo !!!!!!!!!!!!!!!!!!!!!!!!!!!  Error in Defocus by OL, Caution values ==> ( $measured_defocus) <= 0.0001 ) OR ($measured_defocus) >= 200.0 ) OR ($setting_z <= $safty_z_lower) OR ($safty_z_upper <= $setting_z) !!!!!!!!!!!!!!!!!!!!!!!!!!!  
             
                Echo ===> Reset defocus.
                SetDefocus $initial_defocus
                MoveStageTo $init_x $init_y $init_z
                FOCUSCOUNTER := 0    
                skip_message @= "Skipped. Failuer of Auto Focus by OL."
                CallFunction Funcs::AnnotateSkipItem $skip_message
                SkipAcquiringNavItem
                Exit

             # Adjust focus by Z for large defocus (>= $OLFocusRange microns), only at stage is flat
             ElseIf ( ( $range >= $OLFocusLimit ) AND ( ABS ( $curr_angle ) <= 3 ) )
                Echo ===> Requires large change.
                Echo ===> Focus is adjusted by stage movement.

                relax_z1 = ( $defocus / ABS ($defocus) ) * $backlash_z
                relax_z2 = -1 * ( $defocus / ABS ($defocus) ) * $backlash_z
                setting_z = $setting_z + $defocus * 0.8 + $relax_z1
                
                MoveStageTo $setting_x $setting_y $setting_z
                Echo ---> Move to $setting_z [um]
                Echo ---> Relaxing and Settling
                MoveStage 0 0 $relax_z2
                Delay $z_settle_time sec

                If $iter == $max_focusZ_iter
                    skip_message @= "Skipped. Failuer of Auto Focus by Z."
                    CallFunction Funcs::AnnotateSkipItem $skip_message
                    SkipAcquiringNavItem
                    Exit
                EndIf

            # Adjust focus by OL
            Else
                Echo ===> Focus is adjusted by OL.
                setting_defocus = $setting_defocus + $defocus
                SetDefocus $setting_defocus

                If $iter == $max_focus_iter
                    skip_message @= "Skipped. Failuer of Auto Focus by OL."
                    CallFunction Funcs::AnnotateSkipItem $skip_message
                    SkipAcquiringNavItem
                    Exit
                EndIf
            EndIf

        EndLoop

        ReportTickTime
        end_ticks = $repVal1
        CallFunction Funcs::ElapsedTimeMonitor $start_ticks $end_ticks $process

    EndFunction

#######################################################
EndMacro
Macro	34
ScriptName CustomTilt

#===================================================================
# This script is part of the "SPADataCollection". 
# Perfoms tilted-data collection.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

#######################################################

    Function TiltOnHole 0 0

        tilt_step = { 5 10 20 30 40 50 60 70 }
        len_tilt_step = $#tilt_step

        first_step = 1
        dx = 0
        dy = 0
        dx_total = 0
        dy_total = 0

        Loop $len_tilt_step idx

            CallFunction Funcs::WaitForRefilling

            If $first_step == 1
                tilt_template_buffer = $template_buffer
            Else
                tilt_template_buffer = L
            EndIf

            If $TT > $tilt_step[$idx]
                TiltTo ($tilt_step[$idx] + $backlash_tilt)
                TiltTo $tilt_step[$idx]
                V

                IsVariableDefined mesh_bar_crit
                If $repVal1 == 0
                    ElectronStats T
                    mesh_bar_crit = $repVal5 / 2
                EndIf

                ElectronStats A
                electron_count = $repVal5
                If $electron_count < $mesh_bar_crit 
                    Echo ===> Seems to hit the mesh bar.
                    CallFunction ResetTiltStage
                    SetImageShift 0 0
                    skip_message @= "Skipped. Lost beam while stage tilting."
                    CallFunction Funcs::AnnotateSkipItem $skip_message
                    SkipAcquiringNavItem
                    Exit
                EndIf

                AlignTo $tilt_template_buffer
                ReportAlignShift
                dx = $repVal5
                dy = $repVal6 * -1 #?
                dx_total = $dx_total + $dx
                dy_total = $dy_total + $dy
                track_shift = sqrt ( $dx * $dx + $dy * $dy )
                track_shift_total = sqrt ( $dx_total * $dx_total + $dy_total * $dy_total )

                Echo ---> Current angle : $tilt_step[$idx] [degree]
                Echo ---> Shift for align : $track_shift_total (x:$dx_total, y:$dy_total) [nm]
                Echo --------------------------------
                
                If $track_shift >= $max_track_shift
                    CallFunction CustomTilt::ResetTiltStage
                    SetImageShift 0 0
                    skip_message @= "Skipped. Fail of tracking hole while stage tilt."
                    CallFunction Funcs::AnnotateSkipItem $skip_message 
                    SkipAcquiringNavItem
                    Exit
                EndIf

                V
                Copy A L
                first_step = 0

            Else
                TiltTo ($TT + $backlash_tilt)
                TiltTo $TT
                V

                IsVariableDefined mesh_bar_crit
                If $repVal1 == 0
                    ElectronStats T
                    mesh_bar_crit = $repVal5 / 2
                EndIf

                ElectronStats A
                electron_count = $repVal5
                If $electron_count < $mesh_bar_crit 
                    Echo ===> Seems to hit the mesh bar.
                    CallFunction ResetTiltStage
                    SetImageShift 0 0
                    skip_message @= "Skipped. Lost beam while stage tilting."
                    CallFunction Funcs::AnnotateSkipItem $skip_message
                    SkipAcquiringNavItem
                    Exit
                EndIf

                AlignTo $tilt_template_buffer
                ReportAlignShift
                dx = $repVal5
                dy = $repVal6 * -1 #?
                dx_total = $dx_total + $dx
                dy_total = $dy_total + $dy
                track_shift = sqrt ( $dx * $dx + $dy * $dy )
                track_shift_total = sqrt ( $dx_total * $dx_total + $dy_total * $dy_total )

                Echo ---> Current angle : $TT [degree]
                Echo ---> Shift for align : $track_shift_total (x:$dx_total, y:$dy_total) [nm]
                Echo --------------------------------

                If $track_shift >= $max_track_shift
                    CallFunction Funcs::AnnotateSkipItem $skip_message 
                    CallFunction CustomTilt::ResetTiltStage
                    SetImageShift 0 0
                    skip_message @= "Skipped. Failure of tracking hole while stage tilt."
                    SkipAcquiringNavItem
                    Exit
                EndIf

                Break
            EndIf

        EndLoop

    EndFunction

#######################################################

    Function AlignToTiltHole 0 0

        holeshift = $track_shift_total
        align_count = 0
        align_err_count = 0

        ReportDefocus initDefocus

        Loop $max_align_iter

            #? Something unknown happened (Unexpected large defocus was set). So initialize anyway.
            #SetEucentricFocus 
            SetDefocus $initDefocus

            CallFunction Funcs::WaitForRefilling

            If $holeshift < $maxholeshift

                If $align_byIS == 0
                    SetImageShift 0 0 # IS is anyway 8000 8000 for stage shift
                Endif

                Echo ----> Tilt hole align finished
                Break

            Else

                ResetImageShift 2 0.05 # relax stage
                
                # DEBUG =============
                #ReportDefocus $repVal1
                #Echo ---> OL : $repVal1    
                #SetEucentricFocus #? Something unknown happened (Unexpected large defocus was set). So initialize anyway.
                #====================

                CallFunction Funcs::CustomMoveStage 0 0
                V
                AlignTo L
                ReportAlignShift
                dx = $RepVal5
                dy = $RepVal6 * -1
                holeshift = sqrt ( $dx * $dx + $dy * $dy )

                align_count = $align_count + 1

                Echo Hole align iter $align_count
                Echo Shift ---> X:$dx [nm] Y:$dy [nm]
                Echo -------------------

                If $holeshift >= 500
                   align_err_count = $align_err_count + 1
                EndIf

                If $align_err_count >= 3
                    CallFunction Funcs::AnnotateSkipItem $skip_message 
                    CallFunction CustomTilt::ResetTiltStage
                    SetImageShift 0 0
                    skip_message @= "Skipped. Failure of tracking hole while stage tilt."
                    SkipAcquiringNavItem
                    Exit
                EndIf 

            EndIf

        EndLoop
         
        If $holeshift > $maxholeshift
            CallFunction Funcs::AnnotateSkipItem $skip_message 
            CallFunction CustomTilt::ResetTiltStage
            SetImageShift 0 0
            skip_message @= "Skipped. Failure of tracking hole while stage tilt."
            SkipAcquiringNavItem
            Exit
        EndIf

    EndFunction

#######################################################

    Function ResetTiltStage 0 0

        TiltTo (-1 * $backlash_tilt)
        TiltTo $backlash_tilt
        TiltTo 0
        MoveStageTo $x_saved $y_saved $z_saved
        CallFunction Funcs::CustomMoveStage 0 0

    EndFunction

#######################################################
EndMacro
Macro	35
ScriptName FindVectorsRough

   # ===============================
   # Parameters
   # ===============================

   targetZ = -20 # [um]
   targetMag = 2500
   CLapt_before = 1
   CLapt_after = 4

   # ===============================
   # Main 
   # ===============================

   SuppressReports 
   CallFunction EMProperties::LoadAdditionalProperties
   SetImageShift 0 0

   # Set CLapt_before
   RunInShell $setCLapt $CLapt_type $CLapt_before

   # Z by V with target Z offset and magnification
   GoToLowDoseArea V
   ReportMag originalViewMag
   SetMag $targetMag
   ReportMagIndex magIndex
   UpdateLowDoseParams V
   Call Z_byV 

   # Set EucentricFocus
   SetEucentricFocus

   # AutoCorrPeak search
   buf = A
   Copy A R # For debug
   V
   ImageProperties $buf
   bin = $repVal3
   pixsize = $repVal5
   xsize = $repVal1
   ysize = $repVal2

   minspacing = 999
   minangle = 0

   AutoCorrPeakVectors $buf $magIndex
   avgSpacing = $repVal1 # [px]
   vecX_1 = $repVal2 #[binned px]
   vecY_1 = $repVal3 #[binned px]
   angle_1 = ATAN2 ( $vecY_1 $vecX_1 )
   vecX_2 = $repVal4 #[binned px]
   vecY_2 = $repVal5 #[binned px]
   angle_2 = ATAN2 ( $vecY_2 $vecX_2 )


   # Convert from camera to specimen
   factor = 1
   If $useK2K3 == 1
      factor = 2
   EndIf 
   Xin_1 = $vecX_1 * $bin * $factor    # [unbinned px]
   Yin_1 = $vecY_1 * $bin * $factor * -1    # [unbinned px]
   Xin_2 = $vecX_2 * $bin * $factor    # [unbinned px]
   Yin_2 = $vecY_2 * $bin * $factor * -1    # [unbinned px]

   CameraToSpecimenMatrix $magIndex
   XperX = $repVal1
   XperY = $repVal2
   YperX = $repVal3
   YperY = $repVal4

   X1 = $Xin_1 * $XperX + $Yin_1 * $XperY
   Y1 = $Xin_1 * $YperX + $Yin_1 * $YperY
   X2 = $Xin_2 * $XperX + $Yin_2 * $XperY
   Y2 = $Xin_2 * $YperX + $Yin_2 * $YperY

   # ---------- Find vectors for View mode -----------

   Echo ---> $X1, $Y1
   Echo ---> $X2, $Y2

   CallFunction Funcs::ImageShiftValToSpecingAngle $X1 $Y1
   spacingOnSpec_1 = $repVal1
   angleOnSpec_1 = $repVal2
   CallFunction Funcs::ImageShiftValToSpecingAngle $X2 $Y2
   spacingOnSpec_2 = $repVal1
   angleOnSpec_2 = $repVal2

   Echo ======================================
   Echo Vectors at View mode
   Echo ===> $spacingOnSpec_1 $angleOnSpec_1
   Echo ===> $spacingOnSpec_2 $angleOnSpec_2
   Echo ======================================

   RunInShell echo $spacingOnSpec_1 $angleOnSpec_1 $spacingOnSpec_2 $angleOnSpec_2 > $NAVIGATOR_PATHVectors_ViewMode.txt

   # ---------- Convert View vectors to Record mode -----------

   CallFunction FindVectorsRough::ViewISToRecIS $X1 $Y1
   recX1 = $repVal1
   recY1 = $repVal2
   CallFunction FindVectorsRough::ViewISToRecIS $X2 $Y2
   recX2 = $repVal1
   recY2 = $repVal2

   Echo ---> $recX1, $recY1
   Echo ---> $recX2, $recY2

   CallFunction Funcs::ImageShiftValToSpecingAngle $recX1 $recY1
   spacingOnSpec_1 = $repVal1
   angleOnSpec_1 = $repVal2
   CallFunction Funcs::ImageShiftValToSpecingAngle $recX2 $recY2
   spacingOnSpec_2 = $repVal1
   angleOnSpec_2 = $repVal2

   Echo ======================================
   Echo Vectors at Record mode
   Echo ===> $spacingOnSpec_1 $angleOnSpec_1
   Echo ===> $spacingOnSpec_2 $angleOnSpec_2
   Echo ======================================

   RunInShell echo $spacingOnSpec_1 $angleOnSpec_1 $spacingOnSpec_2 $angleOnSpec_2 >  $NAVIGATOR_PATHVectors_RecordMode.txt

   # Set CLapt_after
   SetMag $originalViewMag
   UpdateLowDoseParams V
   GoToLowDoseArea R
   SetImageShift 0 0
   SetEucentricFocus
   ResetDefocus  
   RunInShell $setCLapt $CLapt_type $CLapt_after

   OKBox Finished. Correct CL apterture position at Record mode.

################################################

    Function ViewISToRecIS 2 0 viewISX viewISY

       GoToLowDoseArea V   
       SetImageShift 0 0
       ImageShiftByMicrons $viewISX  $viewISY
       GoToLowDoseArea R
       ReportSpecimenShift 
       recISX = $repVal1
       recISY = $repVal2
       
       Return $recISX $recISY

    EndFunction

################################################
EndMacro
Macro	39
ScriptName EMProperties

#===================================================================
# Additional settings for JEOL microscopes. It will be loaded in other scripts.
# --------------------------------------------------------------------------------------------------------------------
# Made and modified by TF and FM.
#===================================================================

#######################################################

    Function LoadAdditionalProperties

        Echo ---> Calling EMProperties ...
        ScreenUp

        #====================================================
        # Working Directory (Setting directory)
        #====================================================
        WORKING_DIR_PATH @= C:\ProgramData\SerialEM

        #====================================================
        # JEOL TEM type
        #====================================================
        # Column
        narrowGapPP = 0 # 0:No, 1: Yes, If stage tilts -30/+30 degree, then set 0 (No).
        hasOmegaFilter = 1 # 0:No, 1:Yes
        hasLN2Tank = 1 # 0:No, 1:Yes

        # CL aperture
        # 0: CryoARM200, CryoARM200CA, CryoARM300II, F200
        # 1: 2nd CL aperture of first gen CryoARM300
        CLapt_type = 0
        Arm300I = 0 # CryoARM300I, open apertures

        # OL aperture
        OLapt_type = 2 # 2: OL aperure, 3: HC aperture

        # Set Screen Cam ID written in "ActiveCameraList" property. Start from 1, not from 0.
        screenCamID = 2
        mainCamID = 1

        FlashSizeX = 2048
        FlashSizeY = 2048

        # Set -1 not to use this.
        badStageFactorX = -1
        badStageFactorY = -1

        #====================================================
        # Session path setting
        #====================================================
        Try
            ReportNavFile 1
            NAVIGATOR_PATH = $repVal3
        Catch
            Echo ===> Navigator file is close
        EndTry

        #====================================================
        # Stage setting
        #====================================================
        # Stage
        backlash_x      = 0.05 #[um]
        backlash_y      = 0.05 #[um]
        backlash_z      = 1.2 #[um] #0.9
        backlash_tilt   = 5 #[degree]

        # Use approach vector?
        use_apprV   = 0 # 0:No, 1:Yes
        apprV_X1    = -25 #[um]
        apprV_Y1    = -25 #[um]
        apprV_X2    = 5 #[um]
        apprV_Y2    = 5 #[um]

        safty_z_lower = -210 #[um]
        safty_z_upper = 205 #[um]

        eucentric_height = 0 # [um] 
        koehler_z_offset = -120 # [um] -120 for zerofringe

        #====================================================
        # FL control
        #====================================================
        FL_by_PyJEM = 1

        #====================================================
        # Setting for Atlas
        #====================================================
        default_spot_atlas = 7
        mag_atlas = 50
        brightness_atlas = 100 # [%] for SetPercentC2

        overlap_x = 576
        overlap_y = 576
        frame_x = 4956
        frame_y = 3996

        # Full size of atlas
        fullFrameX = 7
        fullFrameY = 10

        # Initial beam shift for Atlas
        AtlasBSX = 0
        AtlasBSY = 0

        # FOV offset from Atlas to Square
        atlas2square_x = 28 # [um]    
        atlas2square_y = 25 # [um]   

        # Camera for Atlas
        # 0: K2/K3
        # 1: DE64
        # 2: DE64 with old DE Server (<2.1)
        # 3: Apollo
        # 4: Flash bottom camera
        camForAtlas = 0

        #====================================================
        # Settingfor Square
        #====================================================
        # Default square mag
        default_SquareMag = 150

        # For square mag illumination
        spot_square = 4
        brightness_square = 100 # [%] for SetPercentC2

        # Initial beam shift for Square
        SquareBSX = 0
        SquareBSY = 0

        # FOV offset from Square to View
        square2view_x = 14 # [um]  
        square2view_y = 24 # [um]  

        # Camera for Square
        # 0: K2/K3
        # 1: DE64
        # 2: DE64 with old DE Server (<2.1)
        # 3: Apollo
        # 4: Flash bottom camera
        camForSquare = 0

        #====================================================
        # Setting for LowDoseMode
        #====================================================
        # Recording camera
        #0: Other,
        #1: K2, 
        #2: K3, 
        #3: DE64,
        #4: Apollo
        recordCam = 2

        #====================================================
        # Z height Offset for View and Record
        #====================================================
        # Offset for Z_byV
        offset_for_Z_byV = 0 #[um]

        #====================================================
        # Initial Beam Shift for View of LowDoseMode 
        #====================================================
        LowDoseBSX = 0
        LowDoseBSY = 0

        #====================================================
        # Python Call setting
        #====================================================
        # AutoLoader
        gridSwapper @=  $WORKING_DIR_PATH\Tool\Transfer_Cartridge.bat

        # Aperture control
        setCLapt @= $WORKING_DIR_PATH\Tool\SetCLaperture.bat
        setOLapt @= $WORKING_DIR_PATH\Tool\SetOLaperture.bat

        # FindInitVector
        cmd_findV @= $WORKING_DIR_PATH\Tool\FindHoleLattice.bat

        # FindInitVector
        cmd_PyHoleFinder @= $WORKING_DIR_PATH\Tool\CallPyHoleFinder.bat

        # FL control command
        If $FL_by_PyJEM == 1
            shiftFL @= "$WORKING_DIR_PATH\Tool\shift_FL_client.bat"
            FLserver @= "$WORKING_DIR_PATH\Tool\shift_FL_server.bat"
        Else
            shiftFL @= "$WORKING_DIR_PATH\Tool\FLUpDownApp.exe"
        EndIf

        #====================================================
        # Setting for FindInitVector
        #====================================================
        useK2K3 = 1 #0: No, 1: Yes, This is because sup-resolution pixel binning is defined as 0.5.

        #====================================================
        # YoneoLocker
        #====================================================
        progdir = C:\Users\VALUEDGATANCUSTOMER\Desktop\yoneoLocr-main
        watchinfile = InputImage.txt

    EndFunction

#######################################################

    Function LoadDefaultFocusParams 0 0

       If $focus_error == 999
           focus_error = 0.2
       EndIf

       If $settle_time == 999
          settle_time = 10
       EndIf

       If $max_focusZ_iter == 999
          max_focusZ_iter = 10
       EndIf

       If $max_focus_iter == 999
          max_focus_iter = 8
       EndIf

       If $z_settle_time == 999
          z_settle_time = 3
       EndIf

       If $OLFocusLimit == 999
          OLFocusLimit = 2 #[um]
       EndIf

       If $focus_th_low == 999
          focus_th_low = -0.2 #[um]
       EndIf

    EndFunction

#######################################################
EndMacro
Macro	43

EndMacro
Macro	60
MoveStage 0 0 -15
EndMacro
Macro	61
ReportNumNavAcquire
EndMacro
Macro	62
SetEucentricFocus
EndMacro
Macro	63
SetBeamBlank 1
EndMacro
Macro	64
LongOperation FF 0
EndMacro
